<!DOCTYPE html>
<html lang="en">
    <script>
        !function(t,e){var o,n,p,r;e.__SV||(window.posthog=e,e._i=[],e.init=function(i,s,a){function g(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(p=t.createElement("script")).type="text/javascript",p.crossOrigin="anonymous",p.async=!0,p.src=s.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(r=t.getElementsByTagName("script")[0]).parentNode.insertBefore(p,r);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="init Ie Ts Ms Ee Es Rs capture Ge calculateEventProperties Os register register_once register_for_session unregister unregister_for_session js getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSurveysLoaded onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey canRenderSurveyAsync identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty Ds Fs createPersonProfile Ls Ps opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing clear_opt_in_out_capturing Cs debug I As getPageViewId captureTraceFeedback captureTraceMetric".split(" "),n=0;n<o.length;n++)g(u,o[n]);e._i.push([i,s,a])},e.__SV=1)}(document,window.posthog||[]);
        posthog.init('phc_DR8GzWFM4BXGN6uqCri7Gx4WxKx0RwyoLzhIjygk0Rt', {
            api_host: 'https://us.i.posthog.com',
            defaults: '2025-05-24',
            person_profiles: 'identified_only', // or 'always' to create profiles for anonymous users as well
        })
    </script>
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Dosis:wght@600&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard | Minutehand</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">

    <link rel="icon" type="image/x-icon" href="icon.ico">
    <meta name="theme-color" content="#8426ff" />

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Countdown">

    <meta property="og:image" content="https://michaeldors.com/Images/countdowncover.jpg" />
    <meta property="og:title" content="Minutehand Dashboard" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://michaeldors.com/mcacountdown/countdowndashboard" />
    <meta property="og:description" content="All of your countdowns in one place." />
    <meta property="og:site_name" content="Michael Dors" />
    <link rel="apple-touch-icon" href="Images/countdownhomescreen.png">
    <script src="supabaseclient.js"></script>
</head>

<body>
    <div class="notch-container" id="toolbar-notch">
        <svg class="curve left" viewBox="0 0 80 45" preserveAspectRatio="none">
          <path d="M80,0 L80,45 L0,45 C30,45 50,0 80,0" fill="black"/>
        </svg>
        <div class="center"></div>
        <svg class="curve right" viewBox="0 0 80 45" preserveAspectRatio="none">
          <path d="M0,0 C30,0 50,45 80,45 L0,45 L0,0" fill="black"/>
        </svg>
      </div>
      <h1 class="textelement" style="font-family: 'Dosis';">Pinned</h1>
    <div class="container">
        <div id="linksContainer" class="links-container">
        </div>
        <div class="onthisday-marquee">
            <div class="marquee-label">On this day</div>
            <div class="marquee-viewport">
                <div class="marquee-scroll">
                    <div id="onthisday"></div>
                </div>
            </div>
        </div>
        <div id="curated">
            <h1 class="textelement" style="font-family: 'Dosis';">
                Curated Countdowns <span class="betatag">BETA</span>
            </h1>
            <div class="presetswrapper">
                <div class="presetsicon"><i id="presetsleft" class="fa-solid fa-angle-left"></i></div>
                <ul class="presetstabs-box" id="presetstabs-box">
                    <li id="endtab" class="imgtab" onclick="MESPreset();"><img src="Backgrounds/Presets/Covers/1.png"></li>
                    <li id="nydtab" class="imgtab" onclick="NYDPreset();"><img src="Backgrounds/Presets/Covers/2.png"</li>
                    <li id="vdtab" class="imgtab" onclick="VDPreset();"><img src="Backgrounds/Presets/Covers/3.png" y</li>
                    <li id="eastab" class="imgtab" onclick="EASTERPreset();"><img src="Backgrounds/Presets/Covers/4.png"</li>
                    <li id="idtab" class="imgtab" onclick="IDPreset();"><img src="Backgrounds/Presets/Covers/5.png"</li>
                    <li id="htab" class="imgtab" onclick="HPreset();"><img src="Backgrounds/Presets/Covers/6.png"</li>
                    <li id="ttab" class="imgtab" onclick="TPreset();"><img src="Backgrounds/Presets/Covers/7.png"</li>
                    <li id="ctab" class="imgtab" onclick="CPreset();"><img src="Backgrounds/Presets/Covers/8.png"</li>
                </ul>
                <div class="presetsicon"><i id="presetsright" class="fa-solid fa-angle-right"></i></div>
            </div>
        </div>
        <h1 class="textelement" style="font-family: 'Dosis';">Your Countdowns</h1>
        <h1 class="textelement" style="font-family: 'Dosis';">Shared With You</h1>
        <div style="margin-bottom:300px;"></div>
        <div class="input-container">
            <a title="Create a new Countdown" href="https://michaeldors.com/mcacountdown/betatimer?createnew=1" id="newcountdownbutton"><i class="fa-solid fa-circle-plus"></i></a>
            <a title="Import a .minutehand file from another device" onclick="importLinks();"><i class="fa-solid fa-file-import"></i></a>
            <a title="Export as a .minutehand file" id="sharebuttonoptions" onclick="exportLinks();"><i class="fa-solid fa-download"></i></a>
            <a title="Reset all Countdown options and saved data" id="reset" class="warning" onclick="resetall();"><i class="fa-solid fa-trash"></i></a>
            <input type="file" id="hiddenFileInput" accept=".minutehand" style="display: none;">
        </div>

<img id="threedtrash" alt="Trash Can" src="3d/backoftrashcanexport.png">
<img id="foregroundtrash" alt="Trash Can" src="3d/frontoftrashcanexport.png">
<div id="trashZone" class="trash-zone">
    <i class="fa-solid fa-trash-can"></i>
    <span>Drop to Delete</span>
</div>

    </div>

    <!-- New drag-and-drop overlay -->
    <div id="dragDropOverlay" class="drag-drop-overlay">
        <i class="fa-solid fa-file-import"></i>
        <span>Drop to Import File</span>
    </div>

    <div id="toast-container"></div>


    <script>
    if (typeof window.supabaseClient !== "undefined" && window.supabaseClient.auth) {
        window.supabaseClient.auth.getSession().then(({ data: { session } }) => {
            if (!session?.user) {
                window.location.href = 'auth';
            }
        });
    }

        

function parameter(name) { //returns the value of the parameter it's sent
    var query = window.location.search.substring(1);
    var parameters = query.split('&');
    for (var i = 0; i < parameters.length; i++) {
        var pair = parameters[i].split('=');
        if (pair[0] == name) {
            return pair[1];
        }
    }
    return null;
}
    
// Check if the browser is WebKit-based
const isWebKit = /AppleWebKit/i.test(navigator.userAgent) && !/Chrome/i.test(navigator.userAgent) && 'WebkitAppearance' in document.documentElement.style;

// Create a <style> tag
let dynamicStyle = document.createElement('style');
dynamicStyle.id = 'dynamic-style';
document.head.appendChild(dynamicStyle);

        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            setDarkMode();
        }
        else{
            setLightMode();
        }

// Function to update styles dynamically
function updateStyles() {
    if (isWebKit) {
        dynamicStyle.innerHTML = `
.card.dragging-over-trash {
    transform: rotate(75deg) scale(0.4);
    background: rgba(255, 83, 83, 0.5);
    z-index: 4000;
    overflow: visible;
    transform-origin: center;
    backface-visibility:visible;
    perspective:1000;
}
        `;
    } else {
        dynamicStyle.innerHTML = `
.card.dragging-over-trash {
    transform: rotate3d(0, 1, 0, -60deg) rotate(75deg) scale(0.5);
    background: rgba(255, 83, 83, 0.5);
    z-index: 4000;
    overflow: visible;
    transform-origin: center;
    backface-visibility:visible;
    perspective:1000;
}
        `;
    }
}

// Call the function to apply the initial styles
updateStyles();


        let links = [];
        let placeholder = null;
        let dragCounter = 0;


async function loadLinks() {
    const savedLinks = localStorage.getItem("dashboardsaved");
    const deletedItemsList = JSON.parse(localStorage.getItem("dashboard_deleted_items") || "[]");
    deletedItems = new Set(deletedItemsList);
    
    if (savedLinks) {
        links = JSON.parse(savedLinks);
        // Only render if no user is authenticated (auth listener will handle authenticated users)
        try {
            const { data } = await supabaseClient.auth.getUser();
            if (!data?.user) {
                renderLinks();
            }
        } catch (error) {
            // If there's an error getting user, render anyway
            renderLinks();
        }
    }
}

function saveLinks() {
    localStorage.setItem('dashboardsaved', JSON.stringify(links));
    localStorage.setItem('dashboard_deleted_items', JSON.stringify(Array.from(deletedItems)));
    // Use debounced save for regular operations
    debouncedSaveDashboard();
}

// Add a separate function for immediate saves (like deletions)
async function saveLinksImmediate() {
    localStorage.setItem('dashboardsaved', JSON.stringify(links));
    localStorage.setItem('dashboard_deleted_items', JSON.stringify(Array.from(deletedItems)));
    // Force immediate sync for deletions
    await saveDashboardToCloud();
    renderLinks();
}

function removeLink(index, event) {
    event.stopPropagation();
    event.preventDefault();

    const cards = document.querySelectorAll('.card');
    const cardToDelete = cards[index];

    // Add deletion animation
    cardToDelete.classList.add('currentlybeingdeleted');

    // Add shift animation to cards after the deleted one
    cards.forEach((card, i) => {
        if (i > index) {
            // Update the card's index and remove button
            card.setAttribute('data-index', i - 1);
            const removeButton = card.querySelector('.remove-button');
            removeButton.setAttribute('onclick', `removeLink(${i - 1}, event)`);

            // Add shift class
            card.classList.add('card-shift');
        }
    });

    setTimeout(() => {
        // Mark the item as deleted before removing it
        const linkToDelete = links[index];
        markAsDeleted(linkToDelete);
        
        // Remove the deleted card
        cardToDelete.remove();
        links.splice(index, 1);
        
        // Save to localStorage and force an immediate cloud sync for deletions
        saveLinksImmediate();

        // Remove shift class from remaining cards
        document.querySelectorAll('.card-shift').forEach(card => {
            card.classList.remove('card-shift');
        });
    }, 500);
}

function exportLinks() {
	const data = localStorage.getItem("dashboardsaved");
	const blob = new Blob([data], { type: "application/json" });
	const url = URL.createObjectURL(blob);

	// Download the file
	const link = document.createElement("a");
	link.href = url;
	link.download = "dashboardsave.minutehand";
	link.click();
	URL.revokeObjectURL(url);
	showToast("Downloading your Dashboard save file", 'info');
}

document.addEventListener('keydown', (event) => {
    if ((event.ctrlKey || event.metaKey) && event.key === 's') {
        event.preventDefault(); // Prevent the default save action
        exportLinks();
        return;
    }
});

document.getElementById('hiddenFileInput').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file && file.name.endsWith('.minutehand')) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                links = data;
                // Clear deleted items tracking when importing a new file
                deletedItems.clear();
                localStorage.removeItem('dashboard_deleted_items');
                saveLinks();
                renderLinks();
            } catch (error) {
                alert('Invalid save code');
                console.error(error);
            }
        };
        reader.readAsText(file);
    } else {
        alert("Please upload a valid .minutehand file.");
    }
});


function importLinks() {
	const hiddenFileInput = document.getElementById('hiddenFileInput');
	hiddenFileInput.click(); // Trigger the hidden file input
}

function renderLinks() {
    const linksContainer = document.getElementById('linksContainer');
    linksContainer.innerHTML = '';

    links.forEach((link, index) => {
        let card = document.createElement('div');
        // Remove card-shift class from initial render
        card.className = 'card';
        card.setAttribute('data-index', index);
        card.setAttribute('data-url', encodeURIComponent(link.url));
        card.innerHTML = `
        	<iframe src="${link.url}${link.url.includes('?') ? '&' : '?'}cardmode=true" title="${link.title}" sandbox="allow-scripts allow-same-origin"></iframe>
            <div class="card-content">
                <h3>${link.title}</h3>
                <i class="remove-button fa-solid fa-thumbtack-slash" onclick="removeLink(${index}, event)" style="cursor:pointer;"></i>
            </div>
        `;

        card.addEventListener('mousedown', dragStart);
        linksContainer.appendChild(card);
    });
}

function resetall() { //remove all saved cookies
        eraseCookie('memsav');
        eraseCookie('coce');
        eraseCookie('minute');
        eraseCookie('millisecond');
        eraseCookie('week');
        eraseCookie('second');
        eraseCookie('day');
        eraseCookie('hour');
        eraseCookie('cookiesAccepted');
        eraseCookie('lcdu');
        
        localStorage.removeItem('dashboardsaved'); //reset dashboard
        localStorage.removeItem('dashboard_deleted_items'); //reset deleted items tracking
        deletedItems.clear(); //clear the in-memory set
        location.reload(); // Reload the page
    }

	       function setCookie(name, value, days) {
        var expires = "";
        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + (value || "") + expires + "; path=/";
    }
    function getCookie(name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }
    function eraseCookie(name) {
        document.cookie = name + '=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
    }

        if(getCookie('increasecontrast')){
            document.documentElement.style.filter = 'contrast(150%)';
        }
        else{
            document.documentElement.style.filter = 'contrast(100%)';
        }

let draggedElement = null;
let isDragging = false;
let startX, startY, startIndex;
let mouseDownTime;
let mouseMoveHandler;

function dragStart(e) {
    if (e.button !== 0) return; // Only respond to left mouse button

    const card = e.target.closest('.card');
    if (!card) return;

    // Check if click was on the delete button
    if (e.target.classList.contains('remove-button')) return;

    mouseDownTime = new Date().getTime();

    // Setup the potential drag
    startX = e.clientX;
    startY = e.clientY;
    startIndex = parseInt(card.getAttribute('data-index'));

    // Add mousemove and mouseup listeners to the document
    mouseMoveHandler = (moveEvent) => checkDragThreshold(moveEvent, card);
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', handleMouseUp);

    // Add global event listeners for safety
    window.addEventListener('blur', cancelDrag);
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) cancelDrag();
    });
}

function handleMouseUp(upEvent){
    const mouseUpTime = new Date().getTime();
    const timeDiff = mouseUpTime - mouseDownTime;

    // If it was a quick click (less than 200ms), treat it as a click to open the link
    if (timeDiff < 200 && !isDragging && !upEvent.target.classList.contains('remove-button')) {
        const card = upEvent.target.closest('.card');
        if (card) {
            const url = decodeURIComponent(card.getAttribute('data-url'));
            if (upEvent.ctrlKey || upEvent.metaKey) {
                window.open(url, '_blank');
            } else {
                window.location.href = url;
            }
        }
    }

    // Clean up all event listeners
    document.removeEventListener('mousemove', mouseMoveHandler);
    document.removeEventListener('mouseup', handleMouseUp);
    window.removeEventListener('blur', cancelDrag);
    document.removeEventListener('visibilitychange', cancelDrag);

    dragEnd(upEvent);
}

    document.addEventListener('visibilitychange', function () { //when the tab changes focus state
       dragEnd();
    }, false);

window.onbeforeunload = dragEnd;

function checkDragThreshold(moveEvent, card) {
    const moveX = moveEvent.clientX - startX;
    const moveY = moveEvent.clientY - startY;
    const distance = Math.sqrt(moveX * moveX + moveY * moveY);
    const timeDiff = new Date().getTime() - mouseDownTime;

    // Only start dragging if mouse has been held for more than 200ms AND moved more than 5 pixels
    if (distance > 5 && timeDiff > 200) {
        startDragging(moveEvent, card);
    }
}

function startDragging(e, card) {
    isDragging = true;
    draggedElement = card;

    // Remove the mousemove handler that checks for drag threshold
    document.removeEventListener('mousemove', mouseMoveHandler);

    // Add handlers for tab switching and window blur
    document.addEventListener('visibilitychange', cancelDrag);
    window.addEventListener('blur', cancelDrag);

    // Create and insert the placeholder
    placeholder = document.createElement('div');
    placeholder.className = 'card placeholder';
    placeholder.style.height = `${draggedElement.offsetHeight}px`;
    placeholder.style.width = `${draggedElement.offsetWidth}px`;
    draggedElement.parentNode.insertBefore(placeholder, draggedElement);

    // Set up the dragged element
    const rect = draggedElement.getBoundingClientRect();
    draggedElement.style.position = 'fixed';
    draggedElement.style.zIndex = 3000;
    draggedElement.style.width = `${rect.width}px`;
    draggedElement.style.height = `${rect.height}px`;

    // Calculate the offset of the mouse position relative to the card's top-left corner
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;

    // Store the offset for use in the drag function
    draggedElement.dataset.offsetX = offsetX;
    draggedElement.dataset.offsetY = offsetY;

    // Set the initial position of the dragged element
    updateElementPosition(e.clientX, e.clientY);

    // Add the drag handler
    document.addEventListener('mousemove', drag);

    // Show the trash zone
    const trashZone = document.getElementById('trashZone');
    trashZone.classList.add('visible');
    document.getElementById('threedtrash').classList.add('visible');
    document.getElementById('foregroundtrash').classList.add('visible');
}

function cancelDrag() {
    if (draggedElement) {
        // Clean up drag-related states and elements
        draggedElement.style.position = '';
        draggedElement.style.zIndex = '';
        draggedElement.style.width = '';
        draggedElement.style.height = '';
        draggedElement.style.left = '';
        draggedElement.style.top = '';

        // Remove drag-over classes
        draggedElement.classList.remove('dragging-over-trash');
        document.getElementById('trashZone').classList.remove('drag-over');

        // Reset trash can elements
        const threedTrash = document.getElementById('threedtrash');
        const foregroundTrash = document.getElementById('foregroundtrash');
        threedTrash.classList.remove('visible', 'following');
        foregroundTrash.classList.remove('visible', 'following');
        threedTrash.style.transform = '';
        foregroundTrash.style.transform = '';
        threedTrash.style.left = '';
        threedTrash.style.top = '';
        foregroundTrash.style.left = '';
        foregroundTrash.style.top = '';

        // Handle placeholder
        if (placeholder) {
            placeholder.parentNode.insertBefore(draggedElement, placeholder);
            placeholder.remove();
            placeholder = null;
        }

        // Update links array and save
        links = Array.from(document.querySelectorAll('.card')).map(card => {
            const url = decodeURIComponent(card.getAttribute('data-url'));
            return links.find(link => link.url === url);
        });
        saveLinks();
        updateCardIndices();

        // Reset all drag-related variables
        draggedElement = null;
        isDragging = false;
        mouseDownTime = null;
    }

    // Remove all event listeners
    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', dragEnd);
    document.removeEventListener('visibilitychange', cancelDrag);
    window.removeEventListener('blur', cancelDrag);
}

function drag(e) {
    if (!draggedElement) return;

    updateElementPosition(e.clientX, e.clientY);

    // Check if the dragged element is over the trash zone
    const trashZone = document.getElementById('trashZone');
    const draggedRect = draggedElement.getBoundingClientRect();
    const trashRect = trashZone.getBoundingClientRect();

    if (draggedRect.right > trashRect.left && 
        draggedRect.left < trashRect.right &&
        draggedRect.bottom > trashRect.top && 
        draggedRect.top < trashRect.bottom) {
        trashZone.classList.add('drag-over');
        draggedElement.classList.add('dragging-over-trash');

        // Get the trash can elements
        const threedTrash = document.getElementById('threedtrash');
        const foregroundTrash = document.getElementById('foregroundtrash');

        threedTrash.classList.add('following');
        foregroundTrash.classList.add('following');

        // Calculate the center position of the dragged element
        const draggedCenterX = draggedRect.left + (draggedRect.width / 2);
        const draggedCenterY = draggedRect.top + (draggedRect.height / 2);

        // Update trash can positions to follow the card
        // Offset the trash can slightly to the right and down
        const trashOffsetX = 100; // Adjust this value to position the trash can
        const trashOffsetY = 80; // Adjust this value to position the trash can
        
        threedTrash.style.transform = `translate(${-trashOffsetX}px, ${-trashOffsetY}px)`;
        foregroundTrash.style.transform = `translate(${-trashOffsetX}px, ${-trashOffsetY}px)`;

        
        // Position the trash cans relative to the card
        threedTrash.style.left = `${draggedCenterX}px`;
        threedTrash.style.top = `${draggedCenterY}px`;
        foregroundTrash.style.left = `${draggedCenterX}px`;
        foregroundTrash.style.top = `${draggedCenterY}px`;
    } else {
        trashZone.classList.remove('drag-over');
        draggedElement.classList.remove('dragging-over-trash');

        // Reset trash can positions
        const threedTrash = document.getElementById('threedtrash');
        const foregroundTrash = document.getElementById('foregroundtrash');

        threedTrash.classList.remove('following');
        foregroundTrash.classList.remove('following');

        threedTrash.style.transform = '';
        foregroundTrash.style.transform = '';
        threedTrash.style.left = '';
        threedTrash.style.top = '';
        foregroundTrash.style.left = '';
        foregroundTrash.style.top = '';

        // Only handle card positioning if not over trash
        const cards = Array.from(document.querySelectorAll('.card:not(.placeholder)'));
        let targetCard = null;
        let targetIndex = startIndex;

        const dragCenterX = draggedRect.left + draggedRect.width / 2;
        const dragCenterY = draggedRect.top + draggedRect.height / 2;

        // Find the closest card based on grid position
        cards.forEach((card, index) => {
            if (card !== draggedElement) {
                const rect = card.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Create "snap zones" around each card
                const snapZoneX = rect.width * 0.7; // 70% of card width
                const snapZoneY = rect.height * 0.7; // 70% of card height

                // Check if dragged card is within snap zone
                if (Math.abs(dragCenterX - centerX) < snapZoneX && 
                    Math.abs(dragCenterY - centerY) < snapZoneY) {

                    // If we haven't found a target yet, or this card is closer
                    if (!targetCard || 
                        (Math.abs(dragCenterY - centerY) < Math.abs(dragCenterY - targetCard.getBoundingClientRect().top + targetCard.getBoundingClientRect().height / 2))) {
                        targetCard = card;
                        targetIndex = index;
                    }
                }
            }
        });

        if (targetCard) {
            const targetRect = targetCard.getBoundingClientRect();

            // Determine if we should place before or after the target
            // Prioritize vertical position first, then horizontal
            const isAfter = dragCenterY > targetRect.top + targetRect.height / 2 ||
                          (Math.abs(dragCenterY - (targetRect.top + targetRect.height / 2)) < 20 && 
                           dragCenterX > targetRect.left + targetRect.width / 2);

            if (isAfter) {
                targetIndex++;
            }

            const currentIndex = cards.indexOf(draggedElement);
            if (targetIndex !== currentIndex) {
                targetCard.parentNode.insertBefore(placeholder, 
                    isAfter ? targetCard.nextSibling : targetCard);
            }
        }
    }
}

function dragEnd(e) {
    const trashZone = document.getElementById('trashZone');
    const threedTrash = document.getElementById('threedtrash');
    const foregroundTrash = document.getElementById('foregroundtrash');

    if (draggedElement) {
        draggedElement.classList.remove('dragging-over-trash');
        const draggedRect = draggedElement.getBoundingClientRect();
        const trashRect = trashZone.getBoundingClientRect();

        // Check if the card was dropped on the trash zone
        if (draggedRect.right > trashRect.left && 
            draggedRect.left < trashRect.right &&
            draggedRect.bottom > trashRect.top && 
            draggedRect.top < trashRect.bottom) {

            // Get the index of the card and remove it
            const index = parseInt(draggedElement.getAttribute('data-index'));
            links.splice(index, 1);
            saveLinks();
            renderLinks();
        } else {
            // Clean up drag-related states and elements
            draggedElement.style.position = '';
            draggedElement.style.zIndex = '';
            draggedElement.style.width = '';
            draggedElement.style.height = '';
            draggedElement.style.left = '';
            draggedElement.style.top = '';

            if (placeholder) {
                placeholder.parentNode.insertBefore(draggedElement, placeholder);
                placeholder.remove();
                placeholder = null;
            }

            // Update the links array based on the new order
            const newLinks = [];
            document.querySelectorAll('.card').forEach((card, index) => {
                const url = decodeURIComponent(card.getAttribute('data-url'));
                const link = links.find(link => link.url === url);
                if (link) {
                    newLinks.push(link);
                }
            });
            links = newLinks;

            saveLinks();
            updateCardIndices();
        }
    }

    // Hide the trash zone
    trashZone.classList.remove('visible');
    document.getElementById('threedtrash').classList.remove('visible');
    document.getElementById('foregroundtrash').classList.remove('visible');
    document.getElementById('threedtrash').classList.remove('following');
    document.getElementById('foregroundtrash').classList.remove('following');
    threedTrash.style.left='';
    threedTrash.style.top='';
    foregroundTrash.style.left='';
    foregroundTrash.style.top='';
    threedTrash.style.transform='';
    foregroundTrash.style.transform='';
    trashZone.classList.remove('drag-over');

    // Reset all drag-related variables
    draggedElement = null;
    isDragging = false;
    mouseDownTime = null;

    // Remove all event listeners
    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', dragEnd);
    document.removeEventListener('visibilitychange', cancelDrag);
    window.removeEventListener('blur', cancelDrag);
    saveDashboardToCloud();
}

function updateCardIndices() {
    document.querySelectorAll('.card').forEach((card, index) => {
        card.setAttribute('data-index', index);
        const removeButton = card.querySelector('.remove-button');
        removeButton.setAttribute('onclick', `removeLink(${index}, event)`);
    });
}

function updateElementPosition(mouseX, mouseY) {
    var positionInfo = draggedElement.getBoundingClientRect();
    var height = positionInfo.height;
    var width = positionInfo.width;

    const offsetX = width / 2;
    const offsetY = height / 2;

    draggedElement.style.left = `${mouseX - offsetX}px`;
    draggedElement.style.top = `${mouseY - offsetY}px`;
}

document.addEventListener('dragenter', (event) => {
    event.preventDefault();
    dragCounter++;
    if (dragCounter === 1) { // Show overlay only on the first enter
        document.getElementById('dragDropOverlay').style.opacity = '1';
        document.getElementById('dragDropOverlay').style.zIndex = '10000';
    }
});

document.addEventListener('dragleave', (event) => {
    event.preventDefault();
    dragCounter--;
    if (dragCounter === 0) { // Hide overlay only when all leaves are done
        document.getElementById('dragDropOverlay').style.opacity = '0';
        setTimeout(() => {
            document.getElementById('dragDropOverlay').style.zIndex = '-10000';
        }, 300);
    }
});

document.addEventListener('dragover', (event) => {
    event.preventDefault();
});

document.addEventListener('drop', (event) => {
    event.preventDefault();
    dragCounter = 0;
    document.getElementById('dragDropOverlay').style.opacity = '0';
    setTimeout(() => {
        document.getElementById('dragDropOverlay').style.zIndex = '-10000';
        }, 300);

    const file = event.dataTransfer.files[0];
    if (file && file.name.endsWith('.minutehand')) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                links = data;
                // Clear deleted items tracking when importing a new file
                deletedItems.clear();
                localStorage.removeItem('dashboard_deleted_items');
                saveLinks();
                renderLinks();
            } catch (error) {
                alert('Invalid save code');
                console.error(error);
            }
        };
        reader.readAsText(file);
    } else {
        alert("Please upload a valid .minutehand file.");
    }
});

      function showToast(message, type = 'info') {
          const toastContainer = document.getElementById('toast-container');
          
          // Create toast element
          const toast = document.createElement('div');
          toast.className = `toast ${type}`;
          
          // Create icon element
          const icon = document.createElement('img');
          icon.className = 'toast-icon';
      if(type == "error"){
          icon.src = "toasticons/error.png";
      }
      else if(type == "info"){
          icon.src = "toasticons/info.png";
      }
      else if(type == "success"){
          icon.src = "toasticons/success.png";
      }
      else if(type == "save"){
          icon.src = "toasticons/save.png";
      }
      else{
          icon.src = "toasticons/info.png";
      }
          
          // Create toast content
          const content = document.createElement('div');
          content.className = 'toast-content';
          content.textContent = message;
          
          // Create close button
          const closeButton = document.createElement('button');
          closeButton.className = 'toast-close';
          closeButton.innerHTML = '<i class="fa-solid fa-circle-xmark"></i>';
          closeButton.onclick = () => removeToast(toast);
          
          // Assemble toast
          toast.appendChild(icon);
          toast.appendChild(content);
          toast.appendChild(closeButton);
          toastContainer.appendChild(toast);
  
          // Use setTimeout to ensure the banner is fully rendered
          setTimeout(() => {
              const toastHeight = toast.offsetHeight;
              icon.style.height = `${toastHeigh}px`;
          }, 1); // Adjust the timeout duration if necessary
          setTimeout(() => {
              const toastHeight = toast.offsetHeight;
              icon.style.height = `${toastHeight}px`;
          }, 3); // Adjust the timeout duration if necessary
          setTimeout(() => {
              const toastHeight = toast.offsetHeight;
              icon.style.height = `${toastHeight}px`;
          }, 5); // Adjust the timeout duration if necessary
          setTimeout(() => {
              const toastHeight = toast.offsetHeight;
              icon.style.height = `${toastHeight}px`;
          }, 10); // Adjust the timeout duration if necessary
          setTimeout(() => {
              const toastHeight = toast.offsetHeight;
              icon.style.height = `${toastHeight}px`;
          }, 20); // Adjust the timeout duration if necessary
          setTimeout(() => {
              const toastHeight = toast.offsetHeight;
              icon.style.height = `${toastHeight}px`;
          }, 50); // Adjust the timeout duration if necessary
          setTimeout(() => {
              const toastHeight = toast.offsetHeight;
              icon.style.height = `${toastHeight}px`;
          }, 100); // Adjust the timeout duration if necessary
          
          // Auto remove after 5 seconds
          setTimeout(() => removeToast(toast), 5000);
      }
  
      function removeToast(toast) {
          toast.style.animation = 'toastslideOut 0.3s ease forwards';
          setTimeout(() => {
            toast.remove();
          }, 300);
        }

        function setLightMode() {
            document.documentElement.style.setProperty('--mainbgcolor', '#ffffff');
            document.documentElement.style.setProperty('--mainforegroundcolor', '#000000');
            document.documentElement.style.setProperty('--blurbackground', 'rgba(239, 239, 239, 0.5)');
            document.documentElement.style.setProperty('--blurbackgroundshadow', '0 8px 16px rgba(255, 255, 255, 0.1)');
            document.documentElement.style.setProperty('--placeholderbg', 'rgba(235, 235, 235, 0.43)');
	    document.documentElement.style.setProperty('--placeholderbordercolor', '#bababa');
        document.documentElement.style.setProperty('--cardbeforeglow', 'inset 0 1.54px 0 rgba(255, 255, 255, 0.3), inset 0 0 18px rgba(255, 255, 255, 0.3)');
        document.documentElement.style.setProperty('--cardborder', '1.54px solid rgba(0, 0, 0, 0.1)');
        }
        
        function setDarkMode() {
            document.documentElement.style.setProperty('--mainbgcolor', '#141414');
            document.documentElement.style.setProperty('--mainforegroundcolor', '#ffffff');
            document.documentElement.style.setProperty('--blurbackground', 'rgba(40, 40, 40, 0.5)');
            document.documentElement.style.setProperty('--blurbackgroundshadow', '0 8px 16px rgba(0, 0, 0, 0.45)');
	    document.documentElement.style.setProperty('--placeholderbg', 'rgba(20, 20, 20, 0.23)');
	    document.documentElement.style.setProperty('--placeholderbordercolor', '#666');
        document.documentElement.style.setProperty('--cardbeforeglow', 'inset 0 0px 0 rgba(255, 255, 255, 0), inset 0 0 0px rgba(255, 255, 255, 0)');
        document.documentElement.style.setProperty('--cardborder', '1.54px solid rgba(255, 255, 255, 0.1)');
        }

window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
    if (event.matches) {
        setDarkMode();
    } else {
        setLightMode();
    }
});

loadLinks().catch(console.error);
// Set up Supabase login and dashboard sync
let isInitialLoad = true;
let deletedItems = new Set(); // Track manually deleted items to prevent re-sync

// Set up dashboard-specific auth handling
supabaseClient.auth.onAuthStateChange(async (_event, session) => {
    console.log('[dashboard] Auth state changed:', _event, session);
    if (session?.user) {
        // Get current user using supabase.auth.getUser() and upsert using correct fields for RLS
        supabaseClient.auth.getUser().then(({ data }) => {
            const userId = data.user?.id;
            const email = data.user?.email;
            const name = data.user?.user_metadata?.full_name;
            const avatar_url = data.user?.user_metadata?.avatar_url;
            console.log('[dashboard] getUser result:', { userId, email, name, avatar_url });
            if (!userId || !email || !name) {
                console.warn('[dashboard] Missing user info, aborting upsert');
                return;
            }
            // Upsert user on every auth state change (not just initial load)
            console.log('[dashboard] Upserting user:', { userId, email, name, avatar_url });
            supabaseClient.from("users").upsert({
                id: userId,
                email,
                name,
                avatar_url,
            }, { onConflict: 'id' })
            .then(({ error }) => {
                if (error) {
                    console.error('[dashboard] Insert error (users):', error.message);
                } else {
                    console.log('[dashboard] User upserted');
                }
            });
            
            // Only fetch dashboard data on initial load to avoid overwriting local changes
            if (isInitialLoad) {
                isInitialLoad = false;
                // Fetch dashboard data for this user only on initial load
                console.log('[dashboard] Fetching dashboard for user:', userId);
                supabaseClient
                    .from('user_dashboards')
                    .select('dashboard_data')
                    .eq('user_id', userId)
                    .maybeSingle()
                    .then(({ data, error: dashFetchError }) => {
                      if (dashFetchError && dashFetchError.code !== 'PGRST116') {
                        console.error('[dashboard] Error loading dashboard:', dashFetchError.message);
                        return;
                      }
                      console.log('[dashboard] Dashboard fetch result:', data);
                      const cloudLinks = data?.dashboard_data || [];
                      const localLinks = JSON.parse(localStorage.getItem("dashboardsaved") || "[]");
                      const deletedItemsList = JSON.parse(localStorage.getItem("dashboard_deleted_items") || "[]");
                      deletedItems = new Set(deletedItemsList);
                      
                      console.log('[dashboard] Local links:', localLinks);
                      console.log('[dashboard] Cloud links:', cloudLinks);
                      console.log('[dashboard] Deleted items:', Array.from(deletedItems));
                      
                      // Merge local and cloud links, filtering out deleted items
                      const mergedLinks = mergeDashboardData(localLinks, cloudLinks);
                      links = mergedLinks;
                      
                      console.log('[dashboard] Merged links:', links);
                      
                      // Save merged data to both local storage and cloud
                      localStorage.setItem('dashboardsaved', JSON.stringify(links));
                      saveDashboardToCloud();
                      renderLinks();
                    });
            } else {
                // On subsequent auth changes, just save current state to cloud
                console.log('[dashboard] User authenticated, saving current dashboard to cloud');
                saveLinks(); // Use debounced save for regular auth changes
            }
        }).catch((err) => {
            console.error('[dashboard] AuthStateChange error:', err);
        });
    } else {
        // User signed out
        console.log('[dashboard] User signed out');
        isInitialLoad = true; // Reset for next sign in
    }
});

// Function to merge local and cloud dashboard data
function mergeDashboardData(localLinks, cloudLinks) {
    const mergedMap = new Map();
    
    // Helper function to create a unique key for a countdown
    const getCountdownKey = (link) => {
        // Use URL as the primary identifier, but also consider title for uniqueness
        return `${link.url}|${link.title}`;
    };
    
    // Helper function to check if a link should be included (not deleted)
    const isNotDeleted = (link) => {
        const key = getCountdownKey(link);
        return !deletedItems.has(key);
    };
    
    console.log('[dashboard] Starting merge process...');
    console.log('[dashboard] Local links count:', localLinks.length);
    console.log('[dashboard] Cloud links count:', cloudLinks.length);
    console.log('[dashboard] Deleted items count:', deletedItems.size);
    
    // Process local links first (they take precedence for conflicts)
    localLinks.forEach(link => {
        if (isNotDeleted(link)) {
            const key = getCountdownKey(link);
            mergedMap.set(key, link);
            console.log('[dashboard] Added local link:', link.title);
        } else {
            console.log('[dashboard] Skipped deleted local link:', link.title);
        }
    });
    
    // Process cloud links, only adding if not already present and not deleted
    cloudLinks.forEach(link => {
        if (isNotDeleted(link)) {
            const key = getCountdownKey(link);
            if (!mergedMap.has(key)) {
                mergedMap.set(key, link);
                console.log('[dashboard] Added cloud link:', link.title);
            } else {
                console.log('[dashboard] Skipped duplicate cloud link:', link.title);
            }
        } else {
            console.log('[dashboard] Skipped deleted cloud link:', link.title);
        }
    });
    
    const result = Array.from(mergedMap.values());
    console.log('[dashboard] Merge complete. Total links:', result.length);
    return result;
}

// Function to mark an item as deleted
function markAsDeleted(link) {
    const key = `${link.url}|${link.title}`;
    deletedItems.add(key);
    // Save deleted items to localStorage
    localStorage.setItem('dashboard_deleted_items', JSON.stringify(Array.from(deletedItems)));
    console.log('[dashboard] Marked as deleted:', link.title, 'Key:', key);
    console.log('[dashboard] Total deleted items:', deletedItems.size);
}

// Function to clear deleted items (useful for testing or if user wants to restore)
function clearDeletedItems() {
    deletedItems.clear();
    localStorage.removeItem('dashboard_deleted_items');
}

// Debug function to help with testing sync functionality
function debugSync() {
    const localLinks = JSON.parse(localStorage.getItem("dashboardsaved") || "[]");
    const deletedItemsList = JSON.parse(localStorage.getItem("dashboard_deleted_items") || "[]");
    
    console.log('=== Dashboard Sync Debug ===');
    console.log('Current links array:', links);
    console.log('Local storage links:', localLinks);
    console.log('Deleted items:', Array.from(deletedItems));
    console.log('Deleted items from localStorage:', deletedItemsList);
    console.log('Is user authenticated:', !!supabaseClient.auth.getUser());
    console.log('===========================');
}

// Make debug function available globally for testing
window.debugSync = debugSync;
window.clearDeletedItems = clearDeletedItems;

// Function to manually trigger a sync (useful for testing)
async function manualSync() {
    console.log('[dashboard] Manual sync triggered');
    const { data } = await supabaseClient.auth.getUser();
    if (!data?.user) {
        console.log('[dashboard] No user authenticated, cannot sync');
        return;
    }
    
    // Fetch current cloud data
    const { data: cloudData, error } = await supabaseClient
        .from('user_dashboards')
        .select('dashboard_data')
        .eq('user_id', data.user.id)
        .maybeSingle();
    
    if (error && error.code !== 'PGRST116') {
        console.error('[dashboard] Error fetching cloud data:', error);
        return;
    }
    
    const cloudLinks = cloudData?.dashboard_data || [];
    const localLinks = JSON.parse(localStorage.getItem("dashboardsaved") || "[]");
    
    console.log('[dashboard] Manual sync - Local links:', localLinks);
    console.log('[dashboard] Manual sync - Cloud links:', cloudLinks);
    
    // Merge and update
    const mergedLinks = mergeDashboardData(localLinks, cloudLinks);
    links = mergedLinks;
    
    console.log('[dashboard] Manual sync - Merged links:', links);
    
    // Save to both local and cloud
    localStorage.setItem('dashboardsaved', JSON.stringify(links));
    await saveDashboardToCloud();
    renderLinks();
    
    console.log('[dashboard] Manual sync completed');
}

// Make manual sync available globally for testing
window.manualSync = manualSync;

// Debounce function to limit API calls
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// Debounced version of saveDashboardToCloud
const debouncedSaveDashboard = debounce(async () => {
    await saveDashboardToCloud();
}, 1000); // Wait 1 second after last change before saving

async function saveDashboardToCloud() {
    // Get current user
    console.log('[dashboard] saveDashboardToCloud called');
    console.log('[dashboard] Current links array:', links);
    
    try {
        const { data } = await supabaseClient.auth.getUser();
        const user = data.user;
        console.log('[dashboard] getUser result:', user);
        if (!user) {
            console.warn('[dashboard] No user, aborting cloud save');
            return;
        }
        const userId = user.id;
        const email = user.email;
        const name = user.user_metadata?.full_name;
        const avatar_url = user.user_metadata?.avatar_url;
        console.log('[dashboard] Saving dashboard for:', { userId, email, name, avatar_url, links });
        if (!userId || !email || !name) {
            showToast("Cloud save failed: missing user info", "error");
            console.error('[dashboard] Cloud save failed: missing user info');
            return;
        }
        const { error } = await supabaseClient
            .from('user_dashboards')
            .upsert({
                user_id: userId,
                dashboard_data: links,
                updated_at: new Date().toISOString()
            }, { onConflict: ['user_id'] });
        if (error) {
            console.error('[dashboard] Failed to save dashboard:', error.message);
            showToast("Cloud save failed", "error");
        } else {
            console.log('[dashboard] Dashboard saved to cloud successfully');
        }
    } catch (error) {
        console.error('[dashboard] Network error during cloud save:', error);
        showToast("Cannot save to cloud - check your connection", "error");
    }
}
    </script>
    <script>
        (function () {
            const onThisDayElement = document.getElementById('onthisday');
            if (!onThisDayElement) return;

            const formatOnThisDayDate = (date) => {
                const months = [
                    'January', 'February', 'March', 'April', 'May', 'June',
                    'July', 'August', 'September', 'October', 'November', 'December'
                ];
                return `${months[date.getMonth()]} ${date.getDate()}`;
            };

            const isPositiveOnThisDayEvent = (text) => {
                const negativeKeywords = [
                    'died', 'death', 'killed', 'murdered', 'assassinated', 'executed', 'war', 'battle', 'bombing',
                    'attack', 'invasion', 'siege', 'massacre', 'genocide', 'disaster', 'crash', 'sinking',
                    'earthquake', 'hurricane', 'fire', 'explosion', 'plague', 'pandemic', 'disease', 'famine',
                    'revolt', 'rebellion', 'coup', 'overthrow', 'prison', 'arrest', 'trial', 'sentenced',
                    'defeat', 'surrender', 'retreat', 'casualties', 'victims', 'tragedy', 'accident'
                ];
                const lowerText = String(text || '').toLowerCase();
                return !negativeKeywords.some((keyword) => lowerText.includes(keyword));
            };

            async function fetchOnThisDayEvents(month, day) {
                try {
                    const monthStr = String(month + 1).padStart(2, '0');
                    const dayStr = String(day).padStart(2, '0');
                    const response = await fetch(`https://api.wikimedia.org/feed/v1/wikipedia/en/onthisday/all/${monthStr}/${dayStr}`);
                    if (!response.ok) throw new Error('Failed to fetch data');
                    const data = await response.json();

                    const events = [];

                    if (Array.isArray(data.events)) {
                        data.events
                            .filter((ev) => ev && ev.year && ev.text && isPositiveOnThisDayEvent(ev.text))
                            .slice(0, 10)
                            .forEach((ev) => {
                                events.push({ year: ev.year, text: ev.text, category: 'Historical Event' });
                            });
                    }

                    if (Array.isArray(data.births)) {
                        data.births
                            .slice(0, 5)
                            .forEach((birth) => {
                                if (birth && birth.year && birth.text) {
                                    events.push({ year: birth.year, text: `Born: ${birth.text}`, category: 'Birth' });
                                }
                            });
                    }

                    // Note: intentionally skipping deaths
                    return events.sort((a, b) => a.year - b.year);
                } catch (error) {
                    console.error('[onthisday] Error fetching historical events:', error);
                    return [
                        { year: 404, text: "Unable to load today's historical events. Please check your internet connection.", category: 'Error' }
                    ];
                }
            }

            function renderOnThisDayMarquee(events, today) {
                try {
                    if (!Array.isArray(events) || events.length === 0) {
                        onThisDayElement.textContent = `${formatOnThisDayDate(today)}  No events available.`;
                        onThisDayElement.setAttribute('data-content', `${formatOnThisDayDate(today)}  No events available.`);
                        return;
                    }
                    const line = events
                        .map((ev) => `${ev.year}: ${ev.text}`)
                        .join('       |       ');
                    const fullText = `                     ${line}`;
                    onThisDayElement.textContent = fullText;
                    onThisDayElement.setAttribute('data-content', fullText);
                } catch (e) {
                    console.error('[onthisday] render error:', e);
                }
            }

            const today = new Date();
            fetchOnThisDayEvents(today.getMonth(), today.getDate())
                .then((events) => renderOnThisDayMarquee(events, today))
                .then(() => {
                    // Force animation to start after content is loaded
                    const marqueeScroll = document.querySelector('.marquee-scroll');
                    if (marqueeScroll) {
                        // Calculate appropriate animation duration based on text length
                        const textLength = onThisDayElement.textContent.length;
                        const baseSpeed = 0.08; // seconds per character
                        const duration = Math.max(30, textLength * baseSpeed); // minimum 30 seconds
                        
                        marqueeScroll.style.animation = 'none';
                        marqueeScroll.offsetHeight; // Trigger reflow
                        marqueeScroll.style.animation = `onthisday-marquee ${duration}s linear infinite`;
                    }
                })
                .catch((err) => {
                    console.error('[onthisday] Unexpected error:', err);
                    const errorText = `${formatOnThisDayDate(today)}  Unable to load today's historical events.`;
                    onThisDayElement.textContent = errorText;
                    onThisDayElement.setAttribute('data-content', errorText);
                });
        })();
    </script>
</body>
<style>
:root{
    --mainbgcolor: #141414;
    /*#ffffff*/
    --mainforegroundcolor:#ffffff;
    /*#000000*/
    --blurbackground: rgba(40, 40, 40, 0.5);
    /*rgba(239, 239, 239, 0.73);*/
    --blurbackgroundshadow: 0 8px 16px rgba(0, 0, 0, 0.45);
    /*rgba(255, 255, 255, 0.1)*/
	--placeholderbg: rgba(20, 20, 20, 0.23);
	/*rgba(220, 220, 220, 0.23)*/
	--placeholderbordercolor: #666;
	/*#bababa*/
    --cardbeforeglow: inset 0 1.54px 0 rgba(255, 255, 255, 0.3), inset 0 0 0px rgba(255, 255, 255, 0);
    /*inset 0 1.54px 0 rgba(255, 255, 255, 0.3), inset 0 0 18px rgba(255, 255, 255, 0.3);*/
    --cardborder:1.54px solid rgba(255, 255, 255, 0.1);
    /*1.54px solid rgba(0, 0, 0, 0.1);*/
}
*{
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
}
body {
    font-family: 'Dosis' , sans-serif;
    margin: 0;
    padding: 0;
    background-color: var(--mainbgcolor);

    /*background-image: url("Backgrounds/dashboardbg.png") !important;*/
    background-size: cover; /* Ensure the image covers the entire background */
    background-position:bottom center;
    background-attachment:fixed;
    background-repeat: no-repeat; /* Prevent the image from repeating */
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    text-align:center;
    padding: 20px;
}

h1 {
    font-family: 'Fredoka One';
    text-align: center;
    color: #333;
}

.input-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 10px;
    margin: 0px 0;
    flex-wrap: wrap;
    bottom:15px;
    position: fixed;
    z-index: 1000000000000000;
    left:50%;
    transform: translateX(-50%);
    width:100vw;
}

input, button {
    margin: 0 5px;
    padding: 10px;
    font-size: 16px;
}

button {
    cursor: pointer;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
}

button:hover {
    background-color: #45a049;
}

.links-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 20px;
    position: relative;
}

.card {
    background: var(--blurbackground);
    backdrop-filter: blur(25px);
    -webkit-backdrop-filter: blur(25px);
    color:var(--mainforegroundcolor);
    border-radius: 15px;
    overflow: hidden;
    box-shadow: var(--blurbackgroundshadow);
    cursor: pointer;
    position: relative;
    display: flex;
    flex-direction: column;
    user-select: none;
    filter:blur(0px);
    transition: transform 0.3s ease, 
                opacity 0.3s ease, 
                background 0.3s ease, 
                filter 0.2s ease-in,
                z-index 0.01s;
    transform: translateX(0);
    will-change: transform, opacity;
    z-index: 2000;

    box-shadow: 0 2px 15px rgba(0, 0, 0, 0.08), /* bottom soft shadow */
    inset 0 -1.3px 0 rgba(0, 0, 0, 0.1);
}

.card::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 15px;
  background: linear-gradient(to bottom right, rgba(255,255,255,0.05), transparent);
  pointer-events: none;
  mix-blend-mode: screen;
  z-index:10000000;
}

.card::before {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 15px;
  pointer-events: none;
  z-index: 1000000;

  box-shadow: var(--cardbeforeglow);

  border: var(--cardborder);
}


.card.currentlybeingdeleted{
    transform: scale(0.8) !important;
    opacity: 0 !important;
    filter: blur(50px) !important;
    z-index: 3000;
}

.card-content {
    padding: 15px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    min-height:20px;
    position:relative;
    align-items: flex-start;
}

.card h3 {
    top:50%;
    transform:translateY(-45%);
    position: relative;
    text-align: left;
	margin: 0;
    width:80%;
    font-family: 'Dosis' , sans-serif;
    overflow:hidden;
}

.card:hover .remove-button{
    background-color: #ff5353;
}

.remove-button {
    cursor:crosshair;
    position: absolute;
    top:50%;
    transform:translateY(-50%);
    right: 15px;
    background-color: rgba(0, 0, 0, 0);
    color: var(--mainforegroundcolor);
    border: none;
    border-radius: 10px;
    padding: 5px 10px;
    cursor: pointer;
	transition:0.3s all;
    z-index:1001;
}

.remove-button:hover {
    background-color: #d00000;
}

iframe {
    width: 100%;
    height: 150px;
    border: none;
    pointer-events: none;
    border-top-left-radius:15px;
    border-top-right-radius: 15px;
    z-index:10000;
}

/* Add a visual cue for dragging */
.card:active {
    cursor: grabbing;
}

.placeholder {
    border: 2px dashed var(--placeholderbordercolor);
    background: var(--placeholderbg);
    backdrop-filter: blur(75px);
    -webkit-backdrop-filter: blur(75px);
    box-shadow: none;
    transition: all 0.2s ease; /* Faster transition for more responsive feel */
z-index: 0;
}

.placeholder::after {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 15px;
  background: none;
  pointer-events: none;
  mix-blend-mode: screen;
  z-index:10000000;
}

.placeholder::before {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 15px;
  pointer-events: none;
  z-index: 1000000;

  box-shadow: none;

  border: none;
}

.betatag {
        background: linear-gradient(#8c52ff, #ff914d);
        border-radius:20px;
        padding:5px 10px 5px;
        color:white;
        font-size:20px;
        margin-left:10px;
    }

    .warning {
        background-color: #ff5353;
    }


    #savedash {
        background-color: #FF9900;
    }


        #sharebuttonoptions {
        background-color: #3AB6FF;
    }



	        #newcountdownbutton {
        background-color: #00ff5e;
        color:black;
    }


	#dashboardbuttonoptions{
        	background-color: #00ff5e;
	}


            .betabutton {
        background: linear-gradient(#8c52ff, #ff914d);
    }


        a {
        font-family: 'Fredoka One';
        background-color: #8426ff;
        text-decoration: none;
        color: white;
        padding: 15px;
        border-radius: 1000px;
        user-select: none;
        cursor: pointer;
        font-size: 20px;
        font-weight: 100;
        display: inline-block;
        width:30px;
        height:30px;
        box-shadow: inset 0 1.54px 0 rgba(255, 255, 255, 0.3), inset 0 -1.3px 0 rgba(0, 0, 0, 0.1);
    }

    a i{
        padding-top:5px;
    }

    #threedtrash {
    position: fixed;
    bottom: -100px;
    right: -1000px;
    z-index: 2010;
    height: 150px;
    transition: 0.5s all ease;
    transform: scale(1);
    pointer-events: none;
}

#foregroundtrash {
    position: fixed;
    bottom: -100px;
    right: -1000px;
    z-index: 40000;
    height: 150px;
    transition: 0.5s all ease;
    transform: scale(1);
    pointer-events: none;
}

#threedtrash.visible, #foregroundtrash.visible {
    bottom: 20px;
    right: 0px;
    overflow: visible;
    height: 200px;
}

#threedtrash.following, #foregroundtrash.following{
    transition: transform 0.1s ease;
}

    .trash-zone {
        opacity:0.5;
        filter: blur(0px);
    position: fixed;
    bottom: -100px; /* Start hidden below the viewport */
    right: -1000px;
    padding: 20px;
    color: rgb(255, 0, 0);
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: all 0.5s ease;
    width:200px;
    height:150px;
    z-index: 2000;
    background: radial-gradient(circle at bottom right, rgba(255, 83, 83, 0.95) 0%, rgba(255, 83, 83, 0.8) 10%, rgba(255, 83, 83, 1) 30%, rgba(255, 83, 83, 0.1) 60%, rgba(255, 83, 83, 0) 80%);
    transform:scale(1);
}

.trash-zone.visible {
    bottom: -50px;
    right:-50px;
    opacity:1;
    filter: blur(40px);
}

.trash-zone i {
    font-size: 2em;
    margin-bottom: 5px;
}

.trash-zone.drag-over {
    transform: scale(1.1);
    filter:blur(30px);
    background: radial-gradient(circle at bottom right, rgba(255, 35, 35,1) 0%, rgba(255, 55, 55, 1) 10%, rgba(255, 83, 83, 0.7) 30%, rgba(255, 83, 83, 0.1) 60%, rgba(255, 83, 83, 0) 80%);
}

/* Add new animation for remaining cards */
.card-shift {
    transform: translateX(-100%);
}

.currentlybeingdeleted {
    transform: scale(0.8) !important;
    opacity: 0 !important;
    filter: blur(50px) !important;
}

/* Remove these unused classes */
.card-shift.shift-left,
.card-shift.shift-up,
.card-shift.shift-diagonal {
    display: none;
}

.drag-drop-overlay {
    display: flex;
    opacity: 0;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(130, 70, 255, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
        color: white;
    font-size: 24px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: -10000;
    transition: opacity 0.3s ease;
}

.drag-drop-overlay i {
    font-size: 48px;
    margin-bottom: 10px;
}

#toast-container {
position: fixed;
top: 20px;
right: 20px;
z-index: 100000000000000000;
}

.toast {
width: var(--toast-width);
margin-bottom: 10px;
border-radius: 12px;
background: rgba(14, 14, 14, 0.65);
box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
backdrop-filter: blur(12px);
-webkit-backdrop-filter: blur(12px);
border: 1px solid rgba(125, 125, 125, 0.3);
display: flex;
align-items: center;
animation: toastslideIn 0.3s ease forwards;
transition: all 0.3s ease;
font-family:Dosis, sans-serif;
}


.toast-icon {
margin-right: 5px;
height:1px;
border-top-left-radius: 12px;
border-bottom-left-radius: 12px;
} 
.toast-content {
flex-grow: 1;
font-size: 14px;
color: #ffffff;
margin:16px
}

.toast-close {
background: none !important;
border: none;
color: #ffffff;
cursor: pointer;
padding: 0 8px;
margin-left:10px;
margin-right:10px;
font-size: 18px;
transition: color 0.2s ease;
}

    .notch-container {
        z-index:10000000000;
        display: flex;
        align-items: flex-end;
        height: 90px;
        width: 520px;
        position: fixed;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0; /* Removes any potential whitespace gaps */
    }
.curve {
width: 161px; /* Slight overlap to prevent gaps */
height: 90px;
flex-shrink: 0;
margin-right: -1px; /* Compensate for overlap */
}

.curve:last-child {
margin-right: 0;
}

.center {
height: 90px;
width: 200px;
background-color: black;
flex-shrink: 0;
margin: 0 -1px; /* Small overlap with curves */
}

/* Update SVG paths for smoother curves */
.left path, .right path {
transition: all 0.3s ease;
}

@keyframes toastslideIn {
from {
  transform: translateX(100%);
filter: blur(40px);
  opacity: 0;
}
to {
  transform: translateX(0);
filter: blur(0px);
  opacity: 1;
}
}

@keyframes toastslideOut {
from {
  transform: translateX(0);
filter: blur(0px);
  opacity: 1;
}
to {
transform: translateX(100%);
filter: blur(60px);
  opacity: 0;
}
}

@media (max-width: 768px) {
:root {
  --toast-width: calc(100vw - 40px);
}

#toast-container {
  right: 50%;
  transform: translateX(50%);
}

.notch-container {
zoom:80%;
    }
.input-container {
zoom:80%;
    }

}

.presetswrapper {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    padding: 0 10px;
    align-items: center;
    justify-content: center;
    display: flex;
    padding: 35px;
    position: relative;
    overflow-x: hidden;
    max-width: 1000px;
    border-radius: 35px;
}

.presetswrapper .presetsicon {
        position: absolute;
        top: 0;
        height: 100%;
        width: 120px;
        display: flex;
        align-items: center;
        text-align: center;
    }

.presetsicon:first-child {
    left: 0;
    display: none;
    background: linear-gradient(90deg, var(--mainbgcolor), transparent);
}

.presetsicon:last-child {
    right: 0;
    justify-content: flex-end;
    background: linear-gradient(-90deg, var(--mainbgcolor), transparent);
}

.presetsicon i {
    width: 45px;
    height: 50%;
    cursor: pointer;
    font-size: 1.2rem;
    text-align: center;
    line-height: 75px;
    color: white;
    background: var(--mainbgcolor);
    border-radius: 50%;
}

.presetswrapper .presetstabs-box {
        display: flex;
        gap: 12px;
        list-style: none;
        overflow-x: hidden;
        overflow-y: hidden;
        scroll-behavior: smooth;
        max-width: 90%;
    }

.presetstabs-box.dragging {
    scroll-behavior: auto;
    cursor: grab;
}

.presetstabs-box .tab {
    margin: 0px;
    cursor: pointer;
    font-size: 1.18rem;
    white-space: nowrap;
    background: linear-gradient(to left, rgba(94, 0, 225, 0.8), #14141400);
    border: #8426FF 1px solid;
    padding: 13px 20px;
    border-radius: 30px;
    transition: 0.5s all;
    color: white;
    font-family: 'Fredoka One';
}

.presetstabs-box .mcatab {
    margin: 0px;
    cursor: pointer;
    font-size: 1.18rem;
    white-space: nowrap;
    background: linear-gradient(to left, rgba(31,179,255,0.5), #14141400);
    border: #26b3ff 1px solid;
    padding: 13px 20px;
    border-radius: 30px;
    transition: 0.5s all;
    color: white;
    font-family: 'Fredoka One';
}



.presetstabs-box.dragging .tab {
    user-select: none;
    pointer-events: none;
    filter: brightness(0.8);
}

.presetstabs-box .tab.active {
    color: #fff;
    background: #8426ff;
    border-color: transparent;
}

.presetstabs-box .tab:hover {
    color: #fff;
    background: #8426ff;
    border-color: transparent;
    border: #141414 1px solid;
    transform: scale(0.9);
    animation: jiggle 0.6s infinite;
    overflow-y: visible;
}
.presetstabs-box .imgtab{
    transition: 0.5s all;
    margin: 0px;
    cursor: pointer;
    white-space: nowrap;
    padding: 13px 10px;
}

.presetstabs-box.dragging .mcatab {
    user-select: none;
    pointer-events: none;
    filter: brightness(0.8);
}


.presetstabs-box .mcatab.active {
    color: #fff;
    background: #26b3ff;
    border-color: transparent;
}

.presetstabs-box.dragging .imgtab {
    user-select: none;
    pointer-events: none;
    filter: brightness(0.8);
}

    .presetstabs-box .imgtab:hover{
    transform: scale(0.9);
    animation: jiggle 1s infinite;
    overflow-y: visible;
}

.presetstabs-box .mcatab:hover {
    color: #fff;
    background: #26b3ff;
    border-color: transparent;
    border: var(--mainbgcolor) 1px solid;
    transform: scale(0.9);
    animation: jiggle 0.6s infinite;
    overflow-y: visible;
}

@keyframes jiggle {
    0% {
        transform: rotate(-0.5deg);
    }

    50% {
        transform: rotate(0.5deg);
    }

    100% {
        transform: rotate(-0.5deg);
    }
}

.tabs-box .imgtab{
    transition: 0.5s all;
    margin: 0px;
    cursor: pointer;
    white-space: nowrap;
    padding: 13px 10px;
}

.imgtab img{
    width:300px;
    border-radius: 10px;
}

.tabs-box.dragging .imgtab {
    user-select: none;
    pointer-events: none;
    filter: brightness(0.8);
}

    .tabs-box .imgtab:hover{
    transform: scale(0.9);
    animation: jiggle 1s infinite;
    overflow-y: visible;
}

.presetstabs-box .imgtab{
    transition: 0.5s all;
    margin: 0px;
    cursor: pointer;
    white-space: nowrap;
    padding: 13px 10px;
}


.onthisday-marquee { display: flex; align-items: center; gap: 12px; padding: 10px 12px; border-radius: 12px; background: #8426ff2a; color:var(--mainforegroundcolor); overflow: hidden; margin-top:20px; box-shadow: 0 2px 15px rgba(0, 0, 0, 0.08), inset 0 -1.3px 0 rgba(0, 0, 0, 0.1);}
        .onthisday-marquee .marquee-label { flex: 0 0 auto; font-family: 'Dosis', system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-weight: 600; opacity: 0.85; }
        .onthisday-marquee .marquee-viewport { position: relative; flex: 1 1 auto; overflow: hidden; min-height: 1.75em; display: flex; align-items: center; -webkit-mask-image: linear-gradient(to right, transparent 0, #000 24px, #000 calc(100% - 24px), transparent 100%); mask-image: linear-gradient(to right, transparent 0, #000 24px, #000 calc(100% - 24px), transparent 100%); -webkit-mask-size: 100% 100%; mask-size: 100% 100%; -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat; }
        .onthisday-marquee .marquee-scroll { display: inline-block; white-space: nowrap; animation: onthisday-marquee 200s linear infinite; will-change: transform; line-height: 1.2; animation-play-state: running; }
        .onthisday-marquee .marquee-scroll::after { content: attr(data-content); position: absolute; left: 100%; margin-left: 50px; }
        .onthisday-marquee:hover .marquee-scroll { animation-play-state: paused; }
        #onthisday { display: flex; align-items: center; height: 100%; white-space: pre; }
        @keyframes onthisday-marquee { from { transform: translateX(0); } to { transform: translateX(-50%); } }
</style>
</html>
