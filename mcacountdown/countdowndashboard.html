<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Dosis:wght@600&display=swap" rel="stylesheet">
<script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/4.0.0/model-viewer.min.js"></script>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Countdown Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />

    <link rel="icon" type="image/x-icon" href="icon.ico">
    <meta name="theme-color" content="#8426ff" />
    
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Countdown">

    <meta property="og:image" content="https://michaeldors.com/Images/countdowncover.jpg" />
    <meta property="og:title" content="Countdown Dashboard - Michael Dors" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://michaeldors.com/mcacountdown/countdowndashboard" />
    <meta property="og:description" content="All of your countdowns in one place." />
    <meta property="og:site_name" content="Michael Dors" />
    <link rel="apple-touch-icon" href="Images/countdownhomescreen.png">
</head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-LCNP5E1F65"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-LCNP5E1F65');
</script>
<body>
    <div class="container">
        <div id="linksContainer" class="links-container">
        </div>
        <model-viewer id="threedtrash" alt="Trash Can" src="3d/trash.glb" ar shadow-intensity="1" touch-action="none" disable-pan disable-tap disable-zoom camera-orbit="0deg 75deg 5.5m"></model-viewer>
        <model-viewer id="foregroundtrash" alt="Trash Can" src="3d/cuttrash.glb" ar shadow-intensity="0" touch-action="none" disable-pan disable-tap disable-zoom camera-orbit="0deg 75deg 5.5m"></model-viewer>


        <div class="input-container">
            <a title="Create a new Countdown" href="https://michaeldors.com/mcacountdown/betatimer.html?createnew=1" id="newcountdownbutton"><i class="fa-solid fa-circle-plus"></i> New Countdown</a>
                <a title="Import a .countdown file from another device" onclick="importLinks();"><i class="fa-solid fa-file-import"></i> Import</a>
                <a title="Export as a .countdown file" id="sharebuttonoptions" onclick="exportLinks();"><i class="fa-solid fa-download"></i> Export</a>
                <a title="Reset all Countdown options and saved data" id="reset" class="warning" onclick="resetcookies();"><i class="fa-solid fa-trash"></i> Reset All</a>
            <input type="file" id="hiddenFileInput" accept=".countdown" style="display: none;">
            </div>

<div id="trashZone" class="trash-zone">
    <i class="fa-solid fa-trash-can"></i>
    <span>Drop to Delete</span>
</div>

    </div>

    <!-- New drag-and-drop overlay -->
    <div id="dragDropOverlay" class="drag-drop-overlay">
        <i class="fa-solid fa-file-import"></i>
        <span>Drop to Import File</span>
    </div>

    <script>
        let links = [];
        let placeholder = null;
        let dragCounter = 0;


function loadLinks() {
    const savedLinks = localStorage.getItem("dashboardsaved");
    if (savedLinks) {
        links = JSON.parse(savedLinks);
        renderLinks();
    }
}

function saveLinks() {
    localStorage.setItem('dashboardsaved', JSON.stringify(links));
}


function removeLink(index, event) {
    event.stopPropagation();
    event.preventDefault();
    
    const cards = document.querySelectorAll('.card');
    const cardToDelete = cards[index];
    
    // Add deletion animation
    cardToDelete.classList.add('currentlybeingdeleted');
    
    // Add shift animation to cards after the deleted one
    cards.forEach((card, i) => {
        if (i > index) {
            // Update the card's index and remove button
            card.setAttribute('data-index', i - 1);
            const removeButton = card.querySelector('.remove-button');
            removeButton.setAttribute('onclick', `removeLink(${i - 1}, event)`);
            
            // Add shift class
            card.classList.add('card-shift');
        }
    });
    
    setTimeout(() => {
        // Remove the deleted card
        cardToDelete.remove();
        links.splice(index, 1);
        saveLinks();
        
        // Remove shift class from remaining cards
        document.querySelectorAll('.card-shift').forEach(card => {
            card.classList.remove('card-shift');
        });
    }, 500);
}

function exportLinks() {
	const data = localStorage.getItem("dashboardsaved");
	const blob = new Blob([data], { type: "application/json" });
	const url = URL.createObjectURL(blob);

	// Download the file
	const link = document.createElement("a");
	link.href = url;
	link.download = "dashboardsave.countdown";
	link.click();
	URL.revokeObjectURL(url);
}

document.getElementById('hiddenFileInput').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file && file.name.endsWith('.countdown')) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                links = data;
                saveLinks();
                renderLinks();
            } catch (error) {
                alert('Invalid save code');
                console.error(error);
            }
        };
        reader.readAsText(file);
    } else {
        alert("Please upload a valid .countdown file.");
    }
});

	    
function importLinks() {
	const hiddenFileInput = document.getElementById('hiddenFileInput');
	hiddenFileInput.click(); // Trigger the hidden file input
}

function renderLinks() {
    const linksContainer = document.getElementById('linksContainer');
    linksContainer.innerHTML = '';
    
    links.forEach((link, index) => {
        let card = document.createElement('div');
        // Remove card-shift class from initial render
        card.className = 'card';
        card.setAttribute('data-index', index);
        card.setAttribute('data-url', encodeURIComponent(link.url));
        card.innerHTML = `
            <iframe src="${link.url}" title="${link.title}" sandbox="allow-scripts allow-same-origin"></iframe>
            <div class="card-content">
                <h3>${link.title}</h3>
                <i class="remove-button fa-solid fa-trash" onclick="removeLink(${index}, event)" style="cursor:pointer;"></i>
            </div>
        `;
        
        card.addEventListener('mousedown', dragStart);
        linksContainer.appendChild(card);
    });
}

function resetcookies() { //remove all saved cookies
        eraseCookie('memsav');
        eraseCookie('coce');
        eraseCookie('minute');
        eraseCookie('millisecond');
        eraseCookie('week');
        eraseCookie('second');
        eraseCookie('day');
        eraseCookie('hour');
        eraseCookie('cookiesAccepted');
        eraseCookie('lcdu');
        updateoptions(); //update classes of settings buttons
        localStorage.removeItem('dashboardsaved'); //reset dashboard
    }

	       function setCookie(name, value, days) {
        var expires = "";
        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + (value || "") + expires + "; path=/";
    }
    function getCookie(name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) == ' ') c = c.substring(1, c.length);
            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
        }
        return null;
    }
    function eraseCookie(name) {
        document.cookie = name + '=; Path=/; Expires=Thu, 01 Jan 1970 00:00:01 GMT;';
    }

let draggedElement = null;
let isDragging = false;
let startX, startY, startIndex;
let mouseDownTime;
let mouseMoveHandler;

function dragStart(e) {
    if (e.button !== 0) return; // Only respond to left mouse button
    
    const card = e.target.closest('.card');
    if (!card) return;

    // Check if click was on the delete button
    if (e.target.classList.contains('remove-button')) return;

    mouseDownTime = new Date().getTime();
    
    // Setup the potential drag
    startX = e.clientX;
    startY = e.clientY;
    startIndex = parseInt(card.getAttribute('data-index'));

    // Add mousemove and mouseup listeners to the document
    mouseMoveHandler = (moveEvent) => checkDragThreshold(moveEvent, card);
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', (upEvent) => {
        const mouseUpTime = new Date().getTime();
        const timeDiff = mouseUpTime - mouseDownTime;
        
        // If it was a quick click (less than 200ms), treat it as a click to open the link
        // Also check that the click wasn't on the delete button
        if (timeDiff < 200 && !isDragging && !upEvent.target.classList.contains('remove-button')) {
            const url = decodeURIComponent(card.getAttribute('data-url'));
            if (upEvent.ctrlKey || upEvent.metaKey) {
                window.open(url, '_blank');
            } else {
                window.location.href = url;
            }
        }
        
        dragEnd(upEvent);
    });
}

function checkDragThreshold(moveEvent, card) {
    const moveX = moveEvent.clientX - startX;
    const moveY = moveEvent.clientY - startY;
    const distance = Math.sqrt(moveX * moveX + moveY * moveY);
    const timeDiff = new Date().getTime() - mouseDownTime;

    // Only start dragging if mouse has been held for more than 200ms AND moved more than 5 pixels
    if (distance > 5 && timeDiff > 200) {
        startDragging(moveEvent, card);
    }
}

function startDragging(e, card) {
    isDragging = true;
    draggedElement = card;

    // Remove the mousemove handler that checks for drag threshold
    document.removeEventListener('mousemove', mouseMoveHandler);

    // Add handlers for tab switching and window blur
    document.addEventListener('visibilitychange', cancelDrag);
    window.addEventListener('blur', cancelDrag);

    // Create and insert the placeholder
    placeholder = document.createElement('div');
    placeholder.className = 'card placeholder';
    placeholder.style.height = `${draggedElement.offsetHeight}px`;
    placeholder.style.width = `${draggedElement.offsetWidth}px`;
    draggedElement.parentNode.insertBefore(placeholder, draggedElement);

    // Set up the dragged element
    const rect = draggedElement.getBoundingClientRect();
    draggedElement.style.position = 'fixed';
    draggedElement.style.zIndex = 3000;
    draggedElement.style.width = `${rect.width}px`;
    draggedElement.style.height = `${rect.height}px`;

    // Calculate the offset of the mouse position relative to the card's top-left corner
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;

    // Store the offset for use in the drag function
    draggedElement.dataset.offsetX = offsetX;
    draggedElement.dataset.offsetY = offsetY;

    // Set the initial position of the dragged element
    updateElementPosition(e.clientX, e.clientY);

    // Add the drag handler
    document.addEventListener('mousemove', drag);

    // Show the trash zone
    const trashZone = document.getElementById('trashZone');
    trashZone.classList.add('visible');
    document.getElementById('threedtrash').classList.add('visible');
    document.getElementById('foregroundtrash').classList.add('visible');
}

function cancelDrag() {
    if (isDragging) {
        dragEnd({ clientX: startX, clientY: startY }); // Simulate a mouseup event
    }
    
    // Remove the event listeners
    document.removeEventListener('visibilitychange', cancelDrag);
    window.removeEventListener('blur', cancelDrag);
}

function drag(e) {
    if (!draggedElement) return;
    
    updateElementPosition(e.clientX, e.clientY);

    // Check if the dragged element is over the trash zone
    const trashZone = document.getElementById('trashZone');
    const draggedRect = draggedElement.getBoundingClientRect();
    const trashRect = trashZone.getBoundingClientRect();
    
    if (draggedRect.right > trashRect.left && 
        draggedRect.left < trashRect.right &&
        draggedRect.bottom > trashRect.top && 
        draggedRect.top < trashRect.bottom) {
        trashZone.classList.add('drag-over');
        draggedElement.classList.add('dragging-over-trash');
    } else {
        trashZone.classList.remove('drag-over');
        draggedElement.classList.remove('dragging-over-trash');
        
        // Only handle card positioning if not over trash
        const cards = Array.from(document.querySelectorAll('.card:not(.placeholder)'));
        let targetCard = null;
        let targetIndex = startIndex;

        const dragCenterX = draggedRect.left + draggedRect.width / 2;
        const dragCenterY = draggedRect.top + draggedRect.height / 2;

        // Find the closest card based on grid position
        cards.forEach((card, index) => {
            if (card !== draggedElement) {
                const rect = card.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                // Create "snap zones" around each card
                const snapZoneX = rect.width * 0.7; // 70% of card width
                const snapZoneY = rect.height * 0.7; // 70% of card height

                // Check if dragged card is within snap zone
                if (Math.abs(dragCenterX - centerX) < snapZoneX && 
                    Math.abs(dragCenterY - centerY) < snapZoneY) {
                    
                    // If we haven't found a target yet, or this card is closer
                    if (!targetCard || 
                        (Math.abs(dragCenterY - centerY) < Math.abs(dragCenterY - targetCard.getBoundingClientRect().top + targetCard.getBoundingClientRect().height / 2))) {
                        targetCard = card;
                        targetIndex = index;
                    }
                }
            }
        });

        if (targetCard) {
            const targetRect = targetCard.getBoundingClientRect();
            
            // Determine if we should place before or after the target
            // Prioritize vertical position first, then horizontal
            const isAfter = dragCenterY > targetRect.top + targetRect.height / 2 ||
                          (Math.abs(dragCenterY - (targetRect.top + targetRect.height / 2)) < 20 && 
                           dragCenterX > targetRect.left + targetRect.width / 2);

            if (isAfter) {
                targetIndex++;
            }

            const currentIndex = cards.indexOf(draggedElement);
            if (targetIndex !== currentIndex) {
                targetCard.parentNode.insertBefore(placeholder, 
                    isAfter ? targetCard.nextSibling : targetCard);
            }
        }
    }
}

function dragEnd(e) {
    const trashZone = document.getElementById('trashZone');
    
    if (draggedElement) {
        draggedElement.classList.remove('dragging-over-trash');
        const draggedRect = draggedElement.getBoundingClientRect();
        const trashRect = trashZone.getBoundingClientRect();
                
        // Check if the card was dropped on the trash zone
        if (draggedRect.right > trashRect.left && 
            draggedRect.left < trashRect.right &&
            draggedRect.bottom > trashRect.top && 
            draggedRect.top < trashRect.bottom) {
            
            // Get the index of the card and remove it
            const index = parseInt(draggedElement.getAttribute('data-index'));
            links.splice(index, 1);
            saveLinks();
            renderLinks();
        } else {
            // Clean up drag-related states and elements
            draggedElement.style.position = '';
            draggedElement.style.zIndex = '';
            draggedElement.style.width = '';
            draggedElement.style.height = '';
            draggedElement.style.left = '';
            draggedElement.style.top = '';

            if (placeholder) {
                placeholder.parentNode.insertBefore(draggedElement, placeholder);
                placeholder.remove();
                placeholder = null;
            }

            // Update the links array based on the new order
            links = Array.from(document.querySelectorAll('.card')).map(card => {
                const url = decodeURIComponent(card.getAttribute('data-url'));
                return links.find(link => link.url === url);
            });

            saveLinks();
            updateCardIndices();
        }
    }

    // Hide the trash zone
    trashZone.classList.remove('visible');
    document.getElementById('threedtrash').classList.remove('visible');
    document.getElementById('foregroundtrash').classList.remove('visible');
    trashZone.classList.remove('drag-over');

    // Reset all drag-related variables
    draggedElement = null;
    isDragging = false;
    mouseDownTime = null;

    // Remove all event listeners
    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', dragEnd);
    document.removeEventListener('visibilitychange', cancelDrag);
    window.removeEventListener('blur', cancelDrag);
}

function updateCardIndices() {
    document.querySelectorAll('.card').forEach((card, index) => {
        card.setAttribute('data-index', index);
        const removeButton = card.querySelector('.remove-button');
        removeButton.setAttribute('onclick', `removeLink(${index}, event)`);
    });
}

function updateElementPosition(mouseX, mouseY) {
    var positionInfo = draggedElement.getBoundingClientRect();
    var height = positionInfo.height;
    var width = positionInfo.width;

    const offsetX = width / 2;
    const offsetY = height / 2;
    
    draggedElement.style.left = `${mouseX - offsetX}px`;
    draggedElement.style.top = `${mouseY - offsetY}px`;
}

document.addEventListener('dragenter', (event) => {
    event.preventDefault();
    dragCounter++;
    if (dragCounter === 1) { // Show overlay only on the first enter
        document.getElementById('dragDropOverlay').style.opacity = '1';
        document.getElementById('dragDropOverlay').style.zIndex = '10000';
    }
});

document.addEventListener('dragleave', (event) => {
    event.preventDefault();
    dragCounter--;
    if (dragCounter === 0) { // Hide overlay only when all leaves are done
        document.getElementById('dragDropOverlay').style.opacity = '0';
        setTimeout(() => {
            document.getElementById('dragDropOverlay').style.zIndex = '-10000';
        }, 300);
    }
});

document.addEventListener('dragover', (event) => {
    event.preventDefault();
});

document.addEventListener('drop', (event) => {
    event.preventDefault();
    dragCounter = 0;
    document.getElementById('dragDropOverlay').style.opacity = '0';
    setTimeout(() => {
        document.getElementById('dragDropOverlay').style.zIndex = '-10000';
        }, 300);
    
    const file = event.dataTransfer.files[0];
    if (file && file.name.endsWith('.countdown')) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                links = data;
                saveLinks();
                renderLinks();
            } catch (error) {
                alert('Invalid save code');
                console.error(error);
            }
        };
        reader.readAsText(file);
    } else {
        alert("Please upload a valid .countdown file.");
    }
});

loadLinks();
    </script>
</body>
<style>
body {
    font-family: 'Dosis' , sans-serif;
    margin: 0;
    padding: 0;
    background-color: #141414;
    
    /*background-image: url("Backgrounds/dashboardbg.png") !important;*/
    background-size: cover; /* Ensure the image covers the entire background */
    background-position:bottom center;
    background-attachment:fixed;
    background-repeat: no-repeat; /* Prevent the image from repeating */
    user-select: none;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    text-align:center;
    padding: 20px;
}

h1 {
    font-family: 'Fredoka One';
    text-align: center;
    color: #333;
}

.input-container {
    position:absolute;
    bottom:0;
    left:0;
}

input, button {
    margin: 0 5px;
    padding: 10px;
    font-size: 16px;
}

button {
    cursor: pointer;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
}

button:hover {
    background-color: #45a049;
}

.links-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 20px;
    position: relative;
}

.card {
    background: rgba(40, 40, 40, 0.5);
    backdrop-filter: blur(25px);
    -webkit-backdrop-filter: blur(25px);
    color:white;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.45);
    cursor: pointer;
    position: relative;
    display: flex;
    flex-direction: column;
    user-select: none;
    filter:blur(0px);
    transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1), 
                opacity 0.3s ease, 
                background 0.3s ease, 
                filter 0.2s ease-in;
    transform: translateX(0);
    will-change: transform, opacity;
    z-index: 2000;
}

.card.dragging-over-trash {
    transform: rotate3d(0, 1, 0, -60deg) rotate(75deg) scale(0.5);
    background: rgba(255, 83, 83, 0.5);
    z-index: 4000;
    overflow: visible;
    perspective: 1000px;
    transform-origin: center;
    backface-visibility: hidden;
}

.card.currentlybeingdeleted{
    transform: scale(0.8) !important;
    opacity: 0 !important;
    filter: blur(50px) !important;
    z-index: 3000;
}

.card-content {
    padding: 15px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    min-height:20px;
    position:relative;
    align-items: flex-start;
}

.card h3 {
    top:50%;
    transform:translateY(-45%);
    position: relative;
    text-align: left;
	margin: 0;
    width:100%;
    font-family: 'Dosis' , sans-serif;
    overflow:hidden;
    line-height: 1;
}

.card:hover .remove-button{
    background-color: #ff5353;
}

.remove-button {
    cursor:crosshair;
    position: absolute;
    top:50%;
    transform:translateY(-50%);
    right: 15px;
    background-color: rgba(0, 0, 0, 0);
    color: white;
    border: none;
    border-radius: 4px;
    padding: 5px 10px;
    cursor: pointer;
	transition:0.3s all;
    z-index:1001;
}

.remove-button:hover {
    background-color: #d00000;
}

iframe {
    width: 100%;
    height: 150px;
    border: none;
    pointer-events: none;
}

/* Add a visual cue for dragging */
.card:active {
    cursor: grabbing;
}

.placeholder {
    border: 2px dashed #666;
    background: rgba(20, 20, 20, 0.23);
    backdrop-filter: blur(75px);
    -webkit-backdrop-filter: blur(75px);
    box-shadow: none;
    transition: all 0.2s ease; /* Faster transition for more responsive feel */
z-index: 1000;
}

.betatag {
        background: linear-gradient(#8c52ff, #ff914d);
        border-radius:20px;
        padding:5px 10px 5px;
        color:white;
        font-size:20px;
        margin-left:10px;
    }

    .warning {
        font-family: 'Fredoka One';
        background-color: #ff5353;
        text-decoration: none;
        color: #ffffff;
        box-shadow: 0 7px 0 #d00000;
        border-radius: 20px;
        padding: 20px;
        user-select: none;
        cursor: pointer;
        font-size: 20px;
        font-weight: 100;
    }

        .warning:hover {
            position: relative;
            box-shadow: 0 5px 0 #d00000;
        }

            .warning:hover:active {
                position: relative;
                box-shadow: none;
            }
            
    #savedash {
        font-family: 'Fredoka One';
        background-color: #FF9900;
        text-decoration: none;
        color: #ffffff;
        box-shadow: 0 7px 0 #bf7200;
        border-radius: 20px;
        padding: 20px;
        user-select: none;
        cursor: pointer;
        font-size: 20px;
        font-weight: 100;
    }

        #savedash:hover {
            position: relative;
            box-shadow: 0 5px 0 #bf7200;
        }

            #savedash:hover:active {
                position: relative;
                box-shadow: none;
            }

        #sharebuttonoptions {
        font-family: 'Fredoka One';
        background-color: #3AB6FF;
        text-decoration: none;
        color: #ffffff;
        box-shadow: 0 7px 0 #1374ad;
        border-radius: 20px;
        padding: 20px;
        user-select: none;
        cursor: pointer;
        font-size: 20px;
        font-weight: 100;
    }

        #sharebuttonoptions:hover {
            position: relative;
            box-shadow: 0 5px 0 #1374ad;
        }

            #sharebuttonoptions:hover:active {
                position: relative;
                box-shadow: none;
            }


	        #newcountdownbutton {
       font-family: 'Fredoka One';
        background-color: #00ff5e;
        text-decoration: none;
        color: black;
        box-shadow: 0 7px 0 #00b041;
        border-radius: 20px;
        padding: 20px;
        user-select: none;
        cursor: pointer;
        font-size: 20px;
        font-weight: 100;
    }

        #newcountdownbutton:hover {
            position: relative;
            box-shadow: 0 5px 0 #00b041;
        }

            #newcountdownbutton:hover:active {
                position: relative;
                box-shadow: none;
            }

	#dashboardbuttonoptions{
		font-family: 'Fredoka One';
        	background-color: #00ff5e;
        text-decoration: none;
        color: #ffffff;
        box-shadow: 0 7px 0 #00b041;
        border-radius: 20px;
        padding: 20px;
        user-select: none;
        cursor: pointer;
        font-size: 20px;
        font-weight: 100;
	}

	        #dashboardbuttonoptions:hover {
            position: relative;
            box-shadow: 0 5px 0 #00b041;
        }

            #dashboardbuttonoptions:hover:active {
                position: relative;
                box-shadow: none;
            }

            .betabutton {
        font-family: 'Fredoka One';
        background: linear-gradient(#8c52ff, #ff914d);
        text-decoration: none;
        color: white;
        box-shadow: 0 7px 0 #c67700;
        border-radius: 20px;
        padding: 20px;
        user-select: none;
        cursor: pointer;
        font-size: 20px;
        font-weight: 100;
    }

        .betabutton:hover {
            position: relative;
            box-shadow: 0 5px 0 #c67700;
        }

            .betabutton:hover:active {
                position: relative;
                box-shadow: none;
            }

        a {
        font-family: 'Fredoka One';
        background-color: #8426ff;
        text-decoration: none;
        color: white;
        box-shadow: 0 7px 0 #4d00b2;
        border-radius: 20px;
        padding: 20px;
        user-select: none;
        cursor: pointer;
        font-size: 20px;
        font-weight: 100;
        margin: 0px 5px 25px 5px;
        display: inline-block;
    }
    a:hover {
        position: relative;
        top: 4px;
        box-shadow: 0 5px 0 #4d00b2;
        display: inline-block;
    }
        a:hover:active {
        position: relative;
        top: 9px;
        box-shadow: none;
        display: inline-block;
    }

    #threedtrash{
        position: fixed;
    bottom: -100px; /* Start hidden below the viewport */
    right: -1000px;
    z-index: 2010;
    height:150px;
    transition:0.5s all ease;
    transform: scale(1);
    }

    #foregroundtrash{
        position: fixed;
    bottom: -100px; /* Start hidden below the viewport */
    right: -1000px;
    z-index: 40000;
    height:150px;
    transition:0.5s all ease;
    transform: scale(1);
    }

    #threedtrash.visible{
    bottom: 20px;
    right:-60px;
    overflow: hidden;
    height:200px;
}

#foregroundtrash.visible{
    bottom: 20px;
    right:-60px;
    overflow: hidden;
    height:200px;
}

    .trash-zone {
        opacity:0.5;
        filter: blur(0px);
    position: fixed;
    bottom: -100px; /* Start hidden below the viewport */
    right: -1000px;
    padding: 20px;
    color: rgb(255, 0, 0);
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: all 0.5s ease;
    width:200px;
    height:150px;
    z-index: 2000;
    background: radial-gradient(circle at bottom right, rgba(255, 83, 83, 0.95) 0%, rgba(255, 83, 83, 0.8) 10%, rgba(255, 83, 83, 1) 30%, rgba(255, 83, 83, 0.1) 60%, rgba(255, 83, 83, 0) 80%);
    transform:scale(1);
}

.trash-zone.visible {
    bottom: -50px;
    right:-50px;
    opacity:1;
    filter: blur(40px);
}

.trash-zone i {
    font-size: 2em;
    margin-bottom: 5px;
}

.trash-zone.drag-over {
    transform: scale(1.1);
    filter:blur(30px);
    background: radial-gradient(circle at bottom right, rgba(255, 35, 35,1) 0%, rgba(255, 55, 55, 1) 10%, rgba(255, 83, 83, 0.7) 30%, rgba(255, 83, 83, 0.1) 60%, rgba(255, 83, 83, 0) 80%);
}

/* Add new animation for remaining cards */
.card-shift {
    transform: translateX(-100%);
}

.currentlybeingdeleted {
    transform: scale(0.8) !important;
    opacity: 0 !important;
    filter: blur(50px) !important;
}

/* Remove these unused classes */
.card-shift.shift-left,
.card-shift.shift-up,
.card-shift.shift-diagonal {
    display: none;
}

.drag-drop-overlay {
    display: flex;
    opacity: 0;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(130, 70, 255, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
        color: white;
    font-size: 24px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: -10000;
    transition: opacity 0.3s ease;
}

.drag-drop-overlay i {
    font-size: 48px;
    margin-bottom: 10px;
}
</style>
</html>
