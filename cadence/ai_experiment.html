<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cadence AI Chart Experiment</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    </script>
    <style>
        body {
            padding: 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .card {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .input-group input,
        .input-group textarea,
        .input-group select {
            width: 100%;
            padding: 0.5rem;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        #json-output {
            font-family: monospace;
            white-space: pre-wrap;
            height: 300px;
            overflow-y: auto;
        }

        .preview-box {
            border: 1px solid var(--border-color);
            background: white;
            /* Always white for chart preview usually? Or theme? Let's stick to theme */
            background: var(--bg-primary);
            min-height: 400px;
            padding: 2rem;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
            position: relative;
        }

        .chart-line {
            line-height: 3em;
            position: relative;
            margin-bottom: 1em;
        }

        .chart-chord {
            position: absolute;
            bottom: 1.2em;
            /* Place above text */
            font-weight: bold;
            color: var(--accent-color);
            font-size: 0.9em;
        }

        .debug-text-item {
            position: absolute;
            border: 1px solid rgba(255, 0, 0, 0.2);
            font-size: 10px;
            color: red;
            white-space: nowrap;
        }

        #pdf-canvas-container {
            position: relative;
            border: 1px solid var(--border-color);
            height: 500px;
            overflow: auto;
            background: #eee;
        }

        canvas {
            display: block;
            margin: 0 auto;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>

<body>

    <h1><i class="fa-solid fa-wand-magic-sparkles"></i> Cadence AI Import Experiment</h1>
    <p class="muted">Upload a PDF chord chart to test AI conversion.</p>

    <div class="input-group">
        <label>OpenRouter API Key</label>
        <input type="password" id="api-key" placeholder="sk-or-..." />
    </div>

    <div class="input-group">
        <label>Model</label>
        <select id="model-select">
            <option value="tngtech/deepseek-r1t2-chimera:free">tngtech/deepseek-r1t2-chimera:free</option>
            <option value="google/gemma-3-27b-it:free">google/gemma-3-27b-it:free</option>
            <option value="deepseek/deepseek-r1-0528:free">deepseek/deepseek-r1-0528:free</option>
            <option value="google/gemini-2.0-flash-exp:free">google/gemini-2.0-flash-exp:free</option>
            <option value="openai/gpt-oss-120b:free">openai/gpt-oss-120b:free</option>
            <option value="meta-llama/llama-3.3-70b-instruct:free">meta-llama/llama-3.3-70b-instruct:free</option>
        </select>
    </div>

    <div class="input-group">
        <label>
            <input type="checkbox" id="two-column-mode" />
            Two-Column Mode (Sort Left side then Right side)
        </label>
    </div>

    <div class="input-group">
        <label>Song Key (Auto-detected or Manual)</label>
        <input type="text" id="song-key" placeholder="e.g. C, Gm, Eb" />
    </div>

    <div class="input-group">
        <label>
            <input type="checkbox" id="use-numbers" checked />
            Convert to Nashville Numbers (requires Key)
        </label>
    </div>

    <div class="container">
        <!-- Left Column: Input & Controls -->
        <div class="left-col">
            <div class="card">
                <h3>1. Source File</h3>
                <div class="input-group">
                    <input type="file" id="file-input" accept="application/pdf" />
                </div>
                <!-- Canvas for PDF Preview -->
                <div id="pdf-canvas-container">
                    <div id="pdf-page-wrapper"></div>
                </div>
            </div>

            <div class="card" style="margin-top: 1rem;">
                <h3>2. Extraction Debug</h3>
                <p class="muted small-text">Extracted text items ready for prompt:</p>
                <div class="input-group">
                    <textarea id="extracted-text-debug" rows="10" readonly></textarea>
                </div>
                <button id="btn-convert" class="btn primary" disabled>
                    <i class="fa-solid fa-robot"></i> Convert with AI
                </button>
                <div id="loading-spinner" class="hidden" style="margin-top: 1rem;">
                    <i class="fa-solid fa-circle-notch fa-spin"></i> Processing...
                </div>
            </div>
        </div>

        <!-- Right Column: Output & Preview -->
        <div class="right-col">
            <div class="card">
                <h3>3. AI JSON Output</h3>
                <div class="input-group">
                    <textarea id="json-output" placeholder="JSON will appear here..."></textarea>
                </div>
                <button id="btn-render" class="btn secondary">Render Preview</button>
            </div>

            <div class="card" style="margin-top: 1rem;">
                <h3>4. Rendered Chart</h3>
                <div id="chart-preview" class="preview-box"></div>
            </div>
        </div>
    </div>

    <script>
        // Utility DOM helper (simplified version of app.js one)
        const el = (id) => document.getElementById(id);

        let extractedItems = [];
        let pdfScale = 1.5;
        let pdfPageWidth = 0; // Store page width for column detection

        // Auto-load API Key from localStorage
        const storedKey = localStorage.getItem('cadence_openai_key');
        if (storedKey) el('api-key').value = storedKey;

        el('api-key').addEventListener('input', (e) => {
            localStorage.setItem('cadence_openai_key', e.target.value);
            checkReady();
        });

        // ==========================================
        // Music Theory Logic (Ported/Adapted from app.js)
        // ==========================================
        const MusicTheory = {
            parseKeyToPitchClass(keyStr) {
                const k = (keyStr || "").trim();
                if (!k) return null;
                // Basic forms: C, C#, Db, Am, F#m, Bb
                const m = k.match(/^([A-Ga-g])([#b]?)(m)?$/);
                if (!m) return null;
                const letter = m[1].toUpperCase();
                const accidental = m[2] || "";
                const isMinor = !!m[3];

                const bases = { C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11 };
                if (bases[letter] === undefined) return null;

                const base = bases[letter];
                let pc = base;
                if (accidental === "#") pc += 1;
                if (accidental === "b") pc -= 1;
                pc = (pc + 12) % 12;
                return { pc, isMinor, preferFlats: accidental === "b" || ["F", "Bb", "Eb", "Ab", "Db", "Gb", "Cb"].includes(letter + accidental) };
            },

            pitchClassToNoteName(pc, preferFlats) {
                const sharps = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
                const flats = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];
                const list = preferFlats ? flats : sharps;
                return list[(pc + 12) % 12];
            },

            chordToNashvilleNumber(chordToken, keyStr) {
                const k = this.parseKeyToPitchClass(keyStr);
                if (!k) return chordToken; // Return original if unknown key

                const tonicPc = k.pc;

                // Parse the chord token (root + quality/bass)
                // Regex to split: Root (A-G + #/b) + The Rest
                const match = chordToken.match(/^([A-G][#b]?)(.*)$/);
                if (!match) return chordToken;

                const rootNote = match[1];
                const tail = match[2]; // m, m7, sus4, /F#, etc.

                // Parse root pitch class
                const rootParsed = this.parseKeyToPitchClass(rootNote);
                if (!rootParsed) return chordToken;
                const rootPc = rootParsed.pc;

                // Calculate interval from Tonic
                const semitones = (rootPc - tonicPc + 12) % 12;

                // Determine Scale Degree based on Interval
                // We use the same scale constants as app.js logic
                let degree = "?";
                let accidental = "";

                // Target Scale Offsets (Major or Minor)
                // We map semitone interval -> { degree, accidental }
                // This is the reverse of the logic in app.js

                if (k.isMinor) {
                    // Natural Minor: 1, 2, b3, 4, 5, b6, b7
                    // Semitones:     0, 2,  3, 5, 7,  8, 10
                    const minorMap = {
                        0: "1", 1: "#1", 2: "2", 3: "3", 4: "#3", 5: "4",
                        6: "#4", 7: "5", 8: "6", 9: "6", 10: "7", 11: "7"
                        // Note: 9 in minor is usually Major 6 vs b6? Natural minor is b6 (8).
                        // Let's be precise:
                        // 0=1, 2=2, 3=3(m), 5=4, 7=5(m), 8=6(maj), 10=7(maj)
                        // If we see 1 (b2), call it b2.
                        // If we see 4 (Maj 3), call it #3 (Picardy?) or just 3 (Maj).
                        // Nashville Number System usually defaults to Major scale referencing even in Minor keys, 
                        // BUT our app.js `nashvilleNumberToChord` uses Natural Minor intervals for '1'..'7'.
                        // So we must match that.
                    };
                    // Let's do a best-effort reverse map based on `scaleOffsets`
                    // [0, 2, 3, 5, 7, 8, 10]
                    switch (semitones) {
                        case 0: degree = "1"; break;
                        case 1: degree = "2"; accidental = "b"; break;
                        case 2: degree = "2"; break;
                        case 3: degree = "3"; break; // This is the diatonic minor 3rd, so just "3"
                        case 4: degree = "3"; accidental = "#"; break; // Major 3rd in minor key
                        case 5: degree = "4"; break;
                        case 6: degree = "5"; accidental = "b"; break; // or #4
                        case 7: degree = "5"; break;
                        case 8: degree = "6"; break; // Diatonic b6
                        case 9: degree = "6"; accidental = "#"; break; // Major 6 (Dorian/Melodic)
                        case 10: degree = "7"; break; // Diatonic b7
                        case 11: degree = "7"; accidental = "#"; break; // Major 7 (Harmonic/Melodic)
                    }
                } else {
                    // Major Key: 1, 2, 3, 4, 5, 6, 7
                    // Semitones: 0, 2, 4, 5, 7, 9, 11
                    switch (semitones) {
                        case 0: degree = "1"; break;
                        case 1: degree = "2"; accidental = "b"; break;
                        case 2: degree = "2"; break;
                        case 3: degree = "3"; accidental = "b"; break;
                        case 4: degree = "3"; break;
                        case 5: degree = "4"; break;
                        case 6: degree = "5"; accidental = "b"; break; // #4 / b5
                        case 7: degree = "5"; break;
                        case 8: degree = "6"; accidental = "b"; break;
                        case 9: degree = "6"; break;
                        case 10: degree = "7"; accidental = "b"; break;
                        case 11: degree = "7"; break;
                    }
                }

                // Handling Bass Notes (Slash Chords) e.g. D/F#
                let newTail = tail;
                if (tail.includes('/')) {
                    const parts = tail.split('/');
                    const qualityPart = parts[0];
                    const bassNoteRaw = parts[1];

                    // Convert bass note to number too
                    const bassNum = this.chordToNashvilleNumber(bassNoteRaw, keyStr);
                    // If bassNum comes back as a number token (digits), use it. 
                    // Warning: recursion might return full string. 
                    // bassNum likely format: "3" or "3..."

                    // We only want the number part for the bass
                    const bassMatch = bassNum.match(/^([b#]?\d+)/);
                    const finalBass = bassMatch ? bassMatch[1] : bassNoteRaw;

                    newTail = qualityPart + "/" + finalBass;
                }

                return `${accidental}${degree}${newTail}`;
            }
        };

        // Expose to window for debugging
        window.MusicTheory = MusicTheory;



        // Re-process on checkbox change
        el('two-column-mode').addEventListener('change', () => {
            // We can't re-read the file easily without storing the blob, 
            // but we can re-sort extractedItems if we kept the raw PDF tokens?
            // Actually, processPDF overwrites extractedItems.
            // Let's just ask user to re-upload for now, or simplify:
            // We'll just trigger the same logic if we had the file.
            // Since we don't store the file object globally, let's just alert.
            if (extractedItems.length === 0) return;
            // Sort and update debug
            sortExtractedItems();
            el('extracted-text-debug').value = JSON.stringify(extractedItems, null, 2);
        });

        el('file-input').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (file.type === 'application/pdf') {
                el('extracted-text-debug').value = "Loading PDF...";
                try {
                    await processPDF(file);
                } catch (err) {
                    console.error("PDF Processing Error:", err);
                    alert("Failed to process PDF: " + err.message);
                    el('extracted-text-debug').value = "Error: " + err.message;
                }
            } else {
                alert('Only PDF supported for now.');
            }
            checkReady();
        });

        function checkReady() {
            const hasKey = el('api-key').value.length > 5;
            const hasData = extractedItems.length > 0;
            const btn = el('btn-convert');
            btn.disabled = !(hasKey && hasData);

            if (!hasKey) {
                btn.title = "Enter API Key first";
            } else if (!hasData) {
                btn.title = "Upload a PDF first";
            } else {
                btn.title = "";
            }
        }

        async function processPDF(file) {
            console.log("Starting processPDF for", file.name);
            const arrayBuffer = await file.arrayBuffer();
            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            const pdf = await loadingTask.promise;
            console.log("PDF loaded, pages:", pdf.numPages);

            const page = await pdf.getPage(1);
            const viewport = page.getViewport({ scale: pdfScale });
            const pdfPageHeight = viewport.height / pdfScale;
            pdfPageWidth = viewport.width / pdfScale;

            const wrapper = el('pdf-page-wrapper');
            wrapper.innerHTML = '';

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;
            canvas.style.maxWidth = "100%";
            canvas.style.height = "auto";
            wrapper.appendChild(canvas);

            await page.render({ canvasContext: context, viewport: viewport }).promise;

            const textContent = await page.getTextContent();

            extractedItems = textContent.items.map(item => {
                return {
                    str: item.str,
                    x: item.transform[4],
                    y: pdfPageHeight - item.transform[5], // Invert Y to Top-Down (0 is top)
                    w: item.width,
                    h: item.height || item.transform[3], // Fallback to font size
                };
            });

            extractedItems = extractedItems.filter(i => i.str.trim().length > 0);

            // Calculate char width for columns
            const heights = extractedItems.map(i => i.h).filter(h => h > 0).sort((a, b) => a - b);
            const medianH = heights.length > 0 ? heights[Math.floor(heights.length / 2)] : 12;
            const charWidth = Math.max(1, medianH * 0.5);

            extractedItems = extractedItems.map(i => ({
                ...i,
                col: Math.round(i.x / charWidth)
            }));

            // Auto-detect columns
            const midPoint = pdfPageWidth / 2;
            const leftItems = extractedItems.filter(i => i.x < midPoint);
            const rightItems = extractedItems.filter(i => i.x >= midPoint);
            const isTwoColumn = leftItems.length > 10 && rightItems.length > 10;
            el('two-column-mode').checked = isTwoColumn;
            console.log(`Auto-detected columns: ${isTwoColumn ? 'Two Columns' : 'Single Column'}`);

            sortExtractedItems();
            el('extracted-text-debug').value = JSON.stringify(extractedItems, null, 2);
        }

        function sortExtractedItems() {
            const useTwoColumns = el('two-column-mode').checked;
            const midPoint = pdfPageWidth / 2;
            // Get charWidth from global calculation (need to store it or re-calculate)
            // Ideally we should have stored it on the items or globally.
            // Let's infer it from one item or just recalculate medianH roughly.
            // Actually, we can just shift the 'col' values.

            // Re-detect columns logic inside here to be safe or rely on toggle.

            if (useTwoColumns) {
                // Find rough column shift amount
                const rightColStartX = midPoint;
                // We want to shift Right Column items to start at 0 (or match Left Column).
                // But we don't know the exact offset. 
                // Simple heuristic: subtract the column offset from 'col'.

                // We need to know charWidth again. 
                // Let's store charWidth globally in processPDF.
            }

            extractedItems.sort((a, b) => {
                if (useTwoColumns) {
                    const aIsLeft = a.x < midPoint;
                    const bIsLeft = b.x < midPoint;
                    if (aIsLeft && !bIsLeft) return -1;
                    if (!aIsLeft && bIsLeft) return 1;
                }
                // Sort by Y (Top-Down): Smaller Y is higher up
                const yDiff = a.y - b.y;
                if (Math.abs(yDiff) > 5) return yDiff;
                return a.x - b.x;
            });

            // Normalize Columns for AI (Visual Reset)
            if (useTwoColumns) {
                // Calculate offset for right side
                // We can't easily change 'col' permanently because sorting might run multiple times.
                // WE SHOULD ONLY CHANGE IT FOR DISPLAY passed to Prompt.
                // So let's NOT change extractedItems here. 
                // We will handle this in buildPrompt or create a temporary mapped array.
            }
        }

        el('btn-convert').addEventListener('click', async () => {
            const key = el('api-key').value;
            const model = el('model-select').value;
            if (!key || extractedItems.length === 0) return;

            el('loading-spinner').classList.remove('hidden');
            el('btn-convert').disabled = true;

            try {
                const prompt = buildPrompt(extractedItems);
                console.log("Sending prompt...", model);
                const result = await callOpenRouter(key, model, prompt);
                console.log("Received response");

                const jsonMatch = result.match(/```json\n([\s\S]*?)\n```/) || result.match(/{[\s\S]*}/);
                let jsonStr = jsonMatch ? (jsonMatch[1] || jsonMatch[0]) : result;

                el('json-output').value = jsonStr;
                const data = JSON.parse(jsonStr);

                // Auto-populate Key if found
                if (data.doc && data.doc.key) {
                    el('song-key').value = data.doc.key;
                }

                renderChart(data);
            } catch (err) {
                console.error("Conversion Error:", err);
                alert('Error: ' + err.message);
                el('json-output').value = "Error: " + err.message;
            } finally {
                el('loading-spinner').classList.add('hidden');
                el('btn-convert').disabled = false;
            }
        });

        el('btn-render').addEventListener('click', () => {
            try {
                const val = el('json-output').value;
                if (!val) return;
                const data = JSON.parse(val);
                renderChart(data);
            } catch (e) { alert('Invalid JSON'); }
        });

        function buildPrompt(items) {
            const useTwoColumns = el('two-column-mode').checked;
            const midPoint = pdfPageWidth / 2;

            // 1. Split into Columns (if needed)
            let leftItems = items;
            let rightItems = [];

            if (useTwoColumns) {
                leftItems = items.filter(i => i.x < midPoint);
                rightItems = items.filter(i => i.x >= midPoint);

                // Normalize Right Column X (Shift to Left)
                if (rightItems.length > 0) {
                    // Robust normalization: use 10th percentile to ignore outliers
                    const sortedCols = rightItems.map(i => i.col).sort((a, b) => a - b);
                    const minRightCol = sortedCols.length > 5
                        ? sortedCols[Math.floor(sortedCols.length * 0.1)]
                        : sortedCols[0];

                    rightItems = rightItems.map(i => ({ ...i, col: Math.max(0, i.col - minRightCol) }));
                }
            } else {
                // Single column: Ensure everything is roughly left-aligned? 
                // No, trust raw X.
            }

            // 2. Group into Logical Rows (Linearize: Left then Right)
            // Function to group items into rows based on Y proximity
            const createRows = (itemList) => {
                const rows = [];
                // Sort by Y (Top-Down) then X
                itemList.sort((a, b) => (a.y - b.y) || (a.x - b.x));

                let currentRow = null;
                const ROW_TOLERANCE = 4; // Pixels (Reduced from 10 to prevent merging close lines)

                itemList.forEach(item => {
                    if (!currentRow) {
                        currentRow = { y: item.y, items: [item] };
                    } else {
                        if (Math.abs(item.y - currentRow.y) < ROW_TOLERANCE) {
                            currentRow.items.push(item);
                        } else {
                            // Finish current row
                            rows.push(currentRow);
                            currentRow = { y: item.y, items: [item] };
                        }
                    }
                });
                if (currentRow) rows.push(currentRow);

                // Sort items within each row by X (Left to Right)
                rows.forEach(r => r.items.sort((a, b) => a.x - b.x));
                return rows;
            };

            const leftRows = createRows(leftItems);
            const rightRows = createRows(rightItems);

            // Combine: Left Rows then Right Rows
            const allRows = [...leftRows, ...rightRows];

            // 3. Generate Prompt Text
            // We give each row a logical "Row ID" to help the AI referencing.
            const linesLog = allRows.map((row, idx) => {
                // Construct string for the row
                // "Ab" (col=0) ... "Gb" (col=10)
                const rowContent = row.items.map(i => `"${i.str}" (col=${i.col})`).join('  ');
                return `ROW ${idx + 1}: ${rowContent}`;
            }).join('\n');

            // DEBUG: Show the rows in the UI
            el('extracted-text-debug').value = "--- GENERATED PROMPT ROWS ---\n" + linesLog;

            return `
You are a music chart converter. I have extracted text tokens from a PDF chord chart.
I have pre-processed the chart into LOGICAL ROWS of text.
If the PDF had two columns, I have already appended the second column AFTER the first one.
So treat this input as a single continuous vertical list.

Your goal is to reconstruct the song structure into a specific JSON format used by our software.

Input Rows:
${linesLog}

Target JSON Format:
{
  "doc": {
      "title": "Song Title",
      "key": "C", 
      "lyricsLines": ["[Verse 1]", "line 1", "line 2", "[Chorus]", "line 1"],
      "placements": [
        { "lineIndex": 1, "charIndex": 5, "value": "C", "kind": "chord" }
      ]
  }
}

Rules:
0. "key":
   - DETECT the key of the song from the chords or title (e.g. "Key: G").
   - If not found, infer it from the first/last chord.
   - Output the Key in the JSON.
1. "lyricsLines":
   - MUST ONLY contain the lyrics text + section headers.
   - NO lines that are just chords.
   - NO metadata (Title, Artist, CCLI).
   - "lyricsLines" should flow naturally line-by-line.

2. "placements" (Chords):
   - **THE GOLDEN RULE**: Chords on "ROW N" belong to the Lyrics on "ROW N+1".
   - **Hyphenated Chords (CRITICAL)**:
     - Lines like "Ab - Bbm" or "Ab / Bbm" are CHORD rows, NOT lyrics.
     - Extract "Ab" and "Bbm" as separate chords for the text line below.
     - IGNORE the hyphen "-".
     - Do not overlap these chords, put them very close, next to each other in the correct order. Don't try to space them out, just make sure they're not overlapped.
   - **Same-Row Chords**:
     - If a Row contains BOTH chords (e.g. "Ab") and Lyrics (e.g. "Words"), extract the chords and place them on the SAME line.
   - **Instrumentals**:
     - If a Row is ONLY chords and the NEXT row is also chords (or a Header), treat it as an Instrumental (create an empty string lyric line).

3. **Section Headers (STRICT)**:
   - Headers like "[Chorus]" usually appear on their own Row.
   - **STRIP METADATA**: Remove repeats/instructions.
     - "[Verse 1(2x)]" -> "[Verse 1]"
     - "[Bridge(Guitar Only)]" -> "[Bridge]"
   - **NO CHORDS ON HEADERS**:
     - The "placements" list for a Header line MUST be empty "[]".
     - If chords appear visually near the header, they belong to the *next* line (Lyrics or Instrumental).

4. **NO HALLUCINATIONS**:
   - ONLY use the text provided in the Input Rows.
   - Do NOT invent chords from previous verses if you don't see them.

5. Output ONLY valid JSON inside \`\`\`json\`\`\` blocks. CRITICAL: Do not summarize, process every single row. If a row has no chords, output an empty placement list for that line. ONLY OUTPUT VALID JSON.
`;
        }

        async function callOpenRouter(apiKey, model, prompt) {
            console.log(prompt);

            const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                method: "POST",
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "Content-Type": "application/json",
                    "HTTP-Referer": window.location.href, // Required for some free tiers
                    "X-Title": "Cadence AI Experiment"
                },
                body: JSON.stringify({
                    "model": model, // Good fast model, usually free/cheap
                    "messages": [
                        { "role": "user", "content": prompt }
                    ]
                })
            });

            if (!response.ok) {
                // Try to get error text
                const errText = await response.text();
                // Check for specific data policy error
                if (errText.includes("data policy") || errText.includes("Free model publication")) {
                    throw new Error('OpenRouter Data Policy Error: You must enable "Allow data logging for free models" in your OpenRouter Privacy Settings to use free models. Go to: https://openrouter.ai/settings/privacy');
                }
                throw new Error('API Error: ' + response.status + ' ' + response.statusText + ' - ' + errText);
            }

            const data = await response.json();
            console.log("Full OpenRouter API Response:", data);

            if (data.error) {
                throw new Error("Provider Error: " + data.error.message);
            }

            if (!data.choices || data.choices.length === 0) {
                throw new Error("No choices returned from API.");
            }

            return data.choices[0].message.content;
        }

        function renderChart(data) {
            const preview = el('chart-preview');
            preview.innerHTML = '';

            const doc = data.doc || data; // Handle if wrapped or not
            const lines = doc.lyricsLines || [];
            const placements = doc.placements || [];

            lines.forEach((lineText, lineIdx) => {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'chart-line';
                // Replace spaces with non-breaking spaces for alignment? 
                // Using pre-wrap handles it mostly, but monospace helps.
                lineDiv.textContent = lineText || ' '; // Ensure height for empty lines

                // Highlight section headers
                if (lineText.trim().match(/^\[([^\]]+)\]$/)) {
                    lineDiv.style.fontWeight = "bold";
                    lineDiv.style.color = "#555";
                    lineDiv.style.marginTop = "1em";
                }

                // Find placements for this line
                const linePlacements = placements.filter(p => p.lineIndex === lineIdx);

                linePlacements.forEach(p => {
                    const chordSpan = document.createElement('span');
                    chordSpan.className = 'chart-chord';
                    chordSpan.textContent = p.value;

                    // Convert to Numbers if enabled
                    const useNumbers = el('use-numbers').checked;
                    const keyStr = el('song-key').value;

                    if (useNumbers && keyStr) {
                        // Simplify value (remove brackets if any?)
                        // The internal value might be "C" or "C/E"
                        const converted = MusicTheory.chordToNashvilleNumber(p.value, keyStr);
                        chordSpan.textContent = converted;
                        chordSpan.title = `Original: ${p.value}`; // Tooltip
                    }

                    // Calculate left position based on char index
                    // Assuming monospace font, 1ch = 1 char width roughly
                    chordSpan.style.left = `${p.charIndex}ch`;
                    lineDiv.appendChild(chordSpan);
                });

                preview.appendChild(lineDiv);
            });
        }
    </script>
</body>

</html>